---
title: "algopy"
---
import { Aside } from '@astrojs/starlight/components';

<a id="module-algopy"></a>

<a id="algopy"></a>

<a id="package-contents"></a>

<a id="classes"></a>

## Classes

| [`ARC4Contract`](algopy.arc4.mdx#algopy.arc4.ARC4Contract)   | The base class for a contract that conforms to the [ARC4 ABI specification](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md). Most contracts<br/>should inherit from this class or a superclass thereof.                               |
|--------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`Account`](#algopy.Account)                                 | An Account on the Algorand network.                                                                                                                                                                                                                          |
| [`Application`](#algopy.Application)                         | An Application on the Algorand network.                                                                                                                                                                                                                      |
| [`Asset`](#algopy.Asset)                                     | An Asset on the Algorand network.                                                                                                                                                                                                                            |
| [`BigUInt`](#algopy.BigUInt)                                 | A variable length (max 512-bit) unsigned integer                                                                                                                                                                                                             |
| [`Box`](#algopy.Box)                                         | Box abstracts the reading and writing of a single value to a single box.<br/>The box size will be reconfigured dynamically to fit the size of the value being assigned to<br/>it.                                                                            |
| [`BoxMap`](#algopy.BoxMap)                                   | BoxMap abstracts the reading and writing of a set of boxes using a common key and content type.<br/>Each composite key (prefix + key) still needs to be made available to the application via the<br/>`boxes` property of the Transaction.                   |
| [`BoxRef`](#algopy.BoxRef)                                   | BoxRef abstracts the reading and writing of boxes containing raw binary data. The size is<br/>configured manually, and can be set to values larger than what the AVM can handle in a single<br/>value.                                                       |
| [`Bytes`](#algopy.Bytes)                                     | A byte sequence, with a maximum length of 4096 bytes, one of the primary data types on the AVM                                                                                                                                                               |
| [`BytesBacked`](#algopy.BytesBacked)                         | Represents a type that is a single bytes value                                                                                                                                                                                                               |
| [`CompiledContract`](#algopy.CompiledContract)               | Provides compiled programs and state allocation values for a Contract.<br/>Create by calling [`compile_contract`](#algopy.compile_contract).                                                                                                                 |
| [`CompiledLogicSig`](#algopy.CompiledLogicSig)               | Provides account for a Logic Signature.<br/>Create by calling [`compile_logicsig`](#algopy.compile_logicsig).                                                                                                                                                |
| [`Contract`](#algopy.Contract)                               | Base class for an Algorand Smart Contract                                                                                                                                                                                                                    |
| [`Global`](algopy.op.mdx#algopy.op.Global)                   | Get Global values<br/>Native TEAL op: [`global`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#global)                                                                                                                         |
| [`GlobalState`](#algopy.GlobalState)                         | Global state associated with the application, the key will be the name of the member, this<br/>is assigned to                                                                                                                                                |
| [`LocalState`](#algopy.LocalState)                           | Local state associated with the application and an account                                                                                                                                                                                                   |
| [`LogicSig`](#algopy.LogicSig)                               | A logic signature                                                                                                                                                                                                                                            |
| [`OnCompleteAction`](#algopy.OnCompleteAction)               | On Completion actions available in an application call transaction                                                                                                                                                                                           |
| [`OpUpFeeSource`](#algopy.OpUpFeeSource)                     | Defines the source of fees for the OpUp utility.                                                                                                                                                                                                             |
| [`StateTotals`](#algopy.StateTotals)                         | Options class to manually define the total amount of global and local state contract will use,<br/>used by [`Contract.__init_subclass__`](#algopy.Contract.__init_subclass__).                                                                               |
| [`String`](#algopy.String)                                   | A UTF-8 encoded string.                                                                                                                                                                                                                                      |
| [`TransactionType`](#algopy.TransactionType)                 | The different transaction types available in a transaction                                                                                                                                                                                                   |
| [`Txn`](algopy.op.mdx#algopy.op.Txn)                         | Get values for the current executing transaction<br/>Native TEAL ops: [`txn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txn), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas) |
| [`UInt64`](#algopy.UInt64)                                   | A 64-bit unsigned integer, one of the primary data types on the AVM                                                                                                                                                                                          |
| [`uenumerate`](#algopy.uenumerate)                           | Yields pairs containing a count (from zero) and a value yielded by the iterable argument.                                                                                                                                                                    |
| [`urange`](#algopy.urange)                                   | Produces a sequence of UInt64 from start (inclusive) to stop (exclusive) by step.                                                                                                                                                                            |

<a id="functions"></a>

## Functions

| [`compile_contract`](#algopy.compile_contract)   | Returns the compiled data for the specified contract                              |
|--------------------------------------------------|-----------------------------------------------------------------------------------|
| [`compile_logicsig`](#algopy.compile_logicsig)   | Returns the Account for the specified logic signature                             |
| [`ensure_budget`](#algopy.ensure_budget)         | Ensure the available op code budget is greater than or equal to required_budget   |
| [`log`](#algopy.log)                             | Concatenates and logs supplied args as a single bytes value.                      |
| [`logicsig`](#algopy.logicsig)                   | Decorator to indicate a function is a logic signature                             |
| [`subroutine`](#algopy.subroutine)               | Decorator to indicate functions or methods that can be called by a Smart Contract |

<a id="data"></a>

## Data

| [`TemplateVar`](#algopy.TemplateVar)   | Template variables can be used to represent a placeholder for a deploy-time provided value.   |
|----------------------------------------|-----------------------------------------------------------------------------------------------|

<a id="api"></a>

## API

<a id="algopy.ARC4Contract"></a>

## *class* algopy.ARC4Contract

ARC4Contract

The base class for a contract that conforms to the [ARC4 ABI specification](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md). Most contracts
should inherit from this class or a superclass thereof.

```python
class HelloWorldContract(ARC4Contract):
    # ...
```

Functions decorated with [`algopy.arc4.abimethod()`](algopy.arc4.mdx#algopy.arc4.abimethod) or [`algopy.arc4.baremethod()`](algopy.arc4.mdx#algopy.arc4.baremethod) will form the public
interface of the contract.

The [`algopy.arc4.ARC4Contract.approval_program()`](algopy.arc4.mdx#algopy.arc4.ARC4Contract.approval_program) will be implemented by the compiler, and route application args
according to the ARC4 ABI specification.

The [`algopy.arc4.ARC4Contract.clear_state_program()`](algopy.arc4.mdx#algopy.arc4.ARC4Contract.clear_state_program) will by default return True, but can be overridden

The Puya compiler will generate ARC32 and ARC56 application specifications for the contract
automatically.

<a id="algopy.ARC4Contract.__init_subclass__"></a>

### *classmethod* \_\_init_subclass_\_

__init_subclass__(\*, name: str = ..., scratch_slots: [algopy.urange](#algopy.urange) | tuple[int | [algopy.urange](#algopy.urange), ...] | list[int | [algopy.urange](#algopy.urange)] = ..., state_totals: [algopy.StateTotals](#algopy.StateTotals) = ..., avm_version: int = ...)

When declaring a Contract subclass, options and configuration are passed in
the base class list:

```python
class MyContract(algopy.Contract, name="CustomName"):
    ...
```

:param name:
Will affect the output TEAL file name if there are multiple non-abstract contracts
in the same file.

If the contract is a subclass of algopy.ARC4Contract, `name` will also be used as the
contract name in the ARC-32 application.json, instead of the class name.

:param scratch_slots:
Allows you to mark a slot ID or range of slot IDs as “off limits” to Puya.
These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.
This is particularly useful in combination with `algopy.op.gload_bytes` / `algopy.op.gload_uint64`
which lets a contract in a group transaction read from the scratch slots of another contract
that occurs earlier in the transaction group.

In the case of inheritance, scratch slots reserved become cumulative. It is not an error
to have overlapping ranges or values either, so if a base class contract reserves slots
0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived
contract all slots 0-10 will be marked as reserved.

:param state_totals:
Allows defining what values should be used for global and local uint and bytes storage
values when creating a contract. Used when outputting ARC-32 application.json schemas.

If let unspecified, the totals will be determined by the compiler based on state
variables assigned to `self`.

This setting is not inherited, and only applies to the exact `Contract` it is specified
on. If a base class does specify this setting, and a derived class does not, a warning
will be emitted for the derived class. To resolve this warning, `state_totals` must be
specified. Note that it is valid to not provide any arguments to the `StateTotals`
constructor, like so `state_totals=StateTotals()`, in which case all values will be
automatically calculated.
:param avm_version:
Determines which AVM version to use, this affects what operations are supported.
Defaults to value provided supplied on command line (which defaults to current mainnet version)

<a id="algopy.ARC4Contract.approval_program"></a>

### approval_program

approval_program() → bool

The approval program for the ARC4Contract is implemented by the compile in
accordance with ARC4

<a id="algopy.ARC4Contract.clear_state_program"></a>

### clear_state_program

clear_state_program() → [algopy.UInt64](#algopy.UInt64) | bool

The clear_state_program contains the logic when the `OnCompletion` is `ClearState`.

The default implementation simply returns True, but this can be overridden.

ClearState transactions always clear local state of the sender. Documentation on
`ClearState` behavior should be read before implementing this method: https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/apps/#clear-state

<a id="algopy.Account"></a>

## *class* algopy.Account

Account(value: str | [algopy.Bytes](#algopy.Bytes) = ..., /)

An Account on the Algorand network.

Note: must be an available resource to access properties other than `bytes`

## Initialization

If `value` is a string, it should be a 58 character base32 string,
ie a base32 string-encoded 32 bytes public key + 4 bytes checksum.
If `value` is a Bytes, it’s length checked to be 32 bytes - to avoid this
check, use `Address.from_bytes(...)` instead.
Defaults to the zero-address.

<a id="algopy.Account.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not equal to the zero-address

<a id="algopy.Account.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.Account](#algopy.Account) | str) → bool

Account equality is determined by the address of another `Account` or `str`

<a id="algopy.Account.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.Account](#algopy.Account) | str) → bool

Account equality is determined by the address of another `Account` or `str`

<a id="algopy.Account.auth_address"></a>

### *property* auth_address

auth_address *: [algopy.Account](#algopy.Account)*

Address the account is rekeyed to

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.balance"></a>

### *property* balance

balance *: [algopy.UInt64](#algopy.UInt64)*

Account balance in microalgos

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.Account.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.Account.is_opted_in"></a>

### is_opted_in

is_opted_in(asset_or_app: [algopy.Asset](#algopy.Asset) | [algopy.Application](#algopy.Application), /) → bool

Returns true if this account is opted in to the specified Asset or Application.

<Aside type="note" title="Note">Account and Asset/Application must be an available resource</Aside>

<a id="algopy.Account.min_balance"></a>

### *property* min_balance

min_balance *: [algopy.UInt64](#algopy.UInt64)*

Minimum required balance for account, in microalgos

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_apps_created"></a>

### *property* total_apps_created

total_apps_created *: [algopy.UInt64](#algopy.UInt64)*

The number of existing apps created by this account.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_apps_opted_in"></a>

### *property* total_apps_opted_in

total_apps_opted_in *: [algopy.UInt64](#algopy.UInt64)*

The number of apps this account is opted into.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_assets"></a>

### *property* total_assets

total_assets *: [algopy.UInt64](#algopy.UInt64)*

The numbers of ASAs held by this account (including ASAs this account created).

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_assets_created"></a>

### *property* total_assets_created

total_assets_created *: [algopy.UInt64](#algopy.UInt64)*

The number of existing ASAs created by this account.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_box_bytes"></a>

### *property* total_box_bytes

total_box_bytes *: [algopy.UInt64](#algopy.UInt64)*

The total number of bytes used by this account’s app’s box keys and values.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_boxes"></a>

### *property* total_boxes

total_boxes *: [algopy.UInt64](#algopy.UInt64)*

The number of existing boxes created by this account’s app.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_extra_app_pages"></a>

### *property* total_extra_app_pages

total_extra_app_pages *: [algopy.UInt64](#algopy.UInt64)*

The number of extra app code pages used by this account.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_num_byte_slice"></a>

### *property* total_num_byte_slice

total_num_byte_slice *: [algopy.UInt64](#algopy.UInt64)*

The total number of byte array values allocated by this account in Global and Local States.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Account.total_num_uint"></a>

### *property* total_num_uint

total_num_uint *: [algopy.UInt64](#algopy.UInt64)*

The total number of uint64 values allocated by this account in Global and Local States.

<Aside type="note" title="Note">Account must be an available resource</Aside>

<a id="algopy.Application"></a>

## *class* algopy.Application

Application(application_id: [algopy.UInt64](#algopy.UInt64) | int = 0, /)

An Application on the Algorand network.

## Initialization

Initialized with the id of an application. Defaults to zero (an invalid ID).

<a id="algopy.Application.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if `application_id` is not `0`

<a id="algopy.Application.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.Application](#algopy.Application)) → bool

Application equality is determined by the equality of an Application’s id

<a id="algopy.Application.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.Application](#algopy.Application)) → bool

Application equality is determined by the equality of an Application’s id

<a id="algopy.Application.address"></a>

### *property* address

address *: [algopy.Account](#algopy.Account)*

Address for which this application has authority

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.approval_program"></a>

### *property* approval_program

approval_program *: [algopy.Bytes](#algopy.Bytes)*

Bytecode of Approval Program

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.clear_state_program"></a>

### *property* clear_state_program

clear_state_program *: [algopy.Bytes](#algopy.Bytes)*

Bytecode of Clear State Program

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.creator"></a>

### *property* creator

creator *: [algopy.Account](#algopy.Account)*

Creator address

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.extra_program_pages"></a>

### *property* extra_program_pages

extra_program_pages *: [algopy.UInt64](#algopy.UInt64)*

Number of Extra Program Pages of code space

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.global_num_bytes"></a>

### *property* global_num_bytes

global_num_bytes *: [algopy.UInt64](#algopy.UInt64)*

Number of byte array values allowed in Global State

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.global_num_uint"></a>

### *property* global_num_uint

global_num_uint *: [algopy.UInt64](#algopy.UInt64)*

Number of uint64 values allowed in Global State

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.id"></a>

### *property* id

id *: [algopy.UInt64](#algopy.UInt64)*

Returns the id of the application

<a id="algopy.Application.local_num_bytes"></a>

### *property* local_num_bytes

local_num_bytes *: [algopy.UInt64](#algopy.UInt64)*

Number of byte array values allowed in Local State

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Application.local_num_uint"></a>

### *property* local_num_uint

local_num_uint *: [algopy.UInt64](#algopy.UInt64)*

Number of uint64 values allowed in Local State

<Aside type="note" title="Note">Application must be an available resource</Aside>

<a id="algopy.Asset"></a>

## *class* algopy.Asset

Asset(asset_id: [algopy.UInt64](#algopy.UInt64) | int = 0, /)

An Asset on the Algorand network.

## Initialization

Initialized with the id of an asset. Defaults to zero (an invalid ID).

<a id="algopy.Asset.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if `asset_id` is not `0`

<a id="algopy.Asset.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.Asset](#algopy.Asset)) → bool

Asset equality is determined by the equality of an Asset’s id

<a id="algopy.Asset.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.Asset](#algopy.Asset)) → bool

Asset equality is determined by the equality of an Asset’s id

<a id="algopy.Asset.balance"></a>

### balance

balance(account: [algopy.Account](#algopy.Account), /) → [algopy.UInt64](#algopy.UInt64)

Amount of the asset unit held by this account. Fails if the account has not
opted in to the asset.

<Aside type="note" title="Note">Asset and supplied Account must be an available resource</Aside>

<a id="algopy.Asset.clawback"></a>

### *property* clawback

clawback *: [algopy.Account](#algopy.Account)*

Clawback address

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.creator"></a>

### *property* creator

creator *: [algopy.Account](#algopy.Account)*

Creator address

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.decimals"></a>

### *property* decimals

decimals *: [algopy.UInt64](#algopy.UInt64)*

See AssetParams.Decimals

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.default_frozen"></a>

### *property* default_frozen

default_frozen *: bool*

Frozen by default or not

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.freeze"></a>

### *property* freeze

freeze *: [algopy.Account](#algopy.Account)*

Freeze address

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.frozen"></a>

### frozen

frozen(account: [algopy.Account](#algopy.Account), /) → bool

Is the asset frozen or not. Fails if the account has not
opted in to the asset.

<Aside type="note" title="Note">Asset and supplied Account must be an available resource</Aside>

<a id="algopy.Asset.id"></a>

### *property* id

id *: [algopy.UInt64](#algopy.UInt64)*

Returns the id of the Asset

<a id="algopy.Asset.manager"></a>

### *property* manager

manager *: [algopy.Account](#algopy.Account)*

Manager address

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.metadata_hash"></a>

### *property* metadata_hash

metadata_hash *: [algopy.Bytes](#algopy.Bytes)*

Arbitrary commitment

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.name"></a>

### *property* name

name *: [algopy.Bytes](#algopy.Bytes)*

Asset name

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.reserve"></a>

### *property* reserve

reserve *: [algopy.Account](#algopy.Account)*

Reserve address

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.total"></a>

### *property* total

total *: [algopy.UInt64](#algopy.UInt64)*

Total number of units of this asset

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.unit_name"></a>

### *property* unit_name

unit_name *: [algopy.Bytes](#algopy.Bytes)*

Asset unit name

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.Asset.url"></a>

### *property* url

url *: [algopy.Bytes](#algopy.Bytes)*

URL with additional info about the asset

<Aside type="note" title="Note">Asset must be an available resource</Aside>

<a id="algopy.BigUInt"></a>

## *class* algopy.BigUInt

BigUInt(value: [algopy.UInt64](#algopy.UInt64) | int = 0, /)

A variable length (max 512-bit) unsigned integer

## Initialization

A BigUInt can be initialized with a UInt64, a Python int literal, or an int variable
declared at the module level

<a id="algopy.BigUInt.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be added with another BigUInt, UInt64 or int e.g. `BigUInt(4) + 2`.

<a id="algopy.BigUInt.__and__"></a>

### \_\_and_\_

__and__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise and with another BigUInt, UInt64 or int e.g. `BigUInt(4) & 2`

<a id="algopy.BigUInt.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

A BigUInt will evaluate to `False` if zero, and `True` otherwise

<a id="algopy.BigUInt.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → bool

A BigUInt can use the `==` operator with another BigUInt, UInt64 or int

<a id="algopy.BigUInt.__floordiv__"></a>

### \_\_floordiv_\_

__floordiv__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be floor divided with another BigUInt, UInt64 or int e.g. `BigUInt(4) // 2`.

This will error on divide by zero

<a id="algopy.BigUInt.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → bool

A BigUInt can use the `>=` operator with another BigUInt, UInt64 or int

<a id="algopy.BigUInt.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → bool

A BigUInt can use the `>` operator with another BigUInt, UInt64 or int

<a id="algopy.BigUInt.__iadd__"></a>

### \_\_iadd_\_

__iadd__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be incremented with another BigUInt, UInt64 or int e.g. `a += BigUInt(2)`.

<a id="algopy.BigUInt.__iand__"></a>

### \_\_iand_\_

__iand__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise and with another BigUInt, UInt64 or int e.g. `a &= BigUInt(2)`

<a id="algopy.BigUInt.__ifloordiv__"></a>

### \_\_ifloordiv_\_

__ifloordiv__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be floor divided with another BigUInt, UInt64 or int e.g. `a //= BigUInt(2)`.

This will error on divide by zero

<a id="algopy.BigUInt.__imod__"></a>

### \_\_imod_\_

__imod__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be modded with another BigUInt, UInt64 or int e.g. `a %= BigUInt(2)`.

This will error on mod by zero

<a id="algopy.BigUInt.__imul__"></a>

### \_\_imul_\_

__imul__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be multiplied with another BigUInt, UInt64 or int e.g. `a*= BigUInt(2)`.

<a id="algopy.BigUInt.__ior__"></a>

### \_\_ior_\_

__ior__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise or with another BigUInt, UInt64 or int e.g. `a |= BigUInt(2)`

<a id="algopy.BigUInt.__isub__"></a>

### \_\_isub_\_

__isub__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be subtracted with another BigUInt, UInt64 or int e.g. `a -= BigUInt(2)`.

This will error on underflow

<a id="algopy.BigUInt.__ixor__"></a>

### \_\_ixor_\_

__ixor__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise xor with another BigUInt, UInt64 or int e.g. `a ^= BigUInt(2)`

<a id="algopy.BigUInt.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → bool

A BigUInt can use the `<=` operator with another BigUInt, UInt64 or int

<a id="algopy.BigUInt.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → bool

A BigUInt can use the `<` operator with another BigUInt, UInt64 or int

<a id="algopy.BigUInt.__mod__"></a>

### \_\_mod_\_

__mod__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be modded with another BigUInt, UInt64 or int e.g. `BigUInt(4) % 2`.

This will error on mod by zero

<a id="algopy.BigUInt.__mul__"></a>

### \_\_mul_\_

__mul__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be multiplied with another BigUInt, UInt64 or int e.g. `4 + BigUInt(2)`.

<a id="algopy.BigUInt.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → bool

A BigUInt can use the `!=` operator with another BigUInt, UInt64 or int

<a id="algopy.BigUInt.__or__"></a>

### \_\_or_\_

__or__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise or with another BigUInt, UInt64 or int e.g. `BigUInt(4) | 2`

<a id="algopy.BigUInt.__pos__"></a>

### \_\_pos_\_

__pos__() → [algopy.BigUInt](#algopy.BigUInt)

Supports unary + operator. Redundant given the type is unsigned

<a id="algopy.BigUInt.__radd__"></a>

### \_\_radd_\_

__radd__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be added with another BigUInt, UInt64 or int e.g. `4 + BigUInt(2)`.

<a id="algopy.BigUInt.__rand__"></a>

### \_\_rand_\_

__rand__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise and with another BigUInt, UInt64 or int e.g. `4 & BigUInt(2)`

<a id="algopy.BigUInt.__rfloordiv__"></a>

### \_\_rfloordiv_\_

__rfloordiv__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be floor divided with another BigUInt, UInt64 or int e.g. `4 // BigUInt(2)`.

This will error on divide by zero

<a id="algopy.BigUInt.__rmod__"></a>

### \_\_rmod_\_

__rmod__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be modded with another BigUInt, UInt64 or int e.g. `4 % BigUInt(2)`.

This will error on mod by zero

<a id="algopy.BigUInt.__rmul__"></a>

### \_\_rmul_\_

__rmul__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be multiplied with another BigUInt, UInt64 or int e.g. `BigUInt(4) + 2`.

<a id="algopy.BigUInt.__ror__"></a>

### \_\_ror_\_

__ror__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise or with another BigUInt, UInt64 or int e.g. `4 | BigUInt(2)`

<a id="algopy.BigUInt.__rsub__"></a>

### \_\_rsub_\_

__rsub__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be subtracted with another BigUInt, UInt64 or int e.g. `4 - BigUInt(2)`.

This will error on underflow

<a id="algopy.BigUInt.__rxor__"></a>

### \_\_rxor_\_

__rxor__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise xor with another BigUInt, UInt64 or int e.g. `4 ^ BigUInt(2)`

<a id="algopy.BigUInt.__sub__"></a>

### \_\_sub_\_

__sub__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can be subtracted with another BigUInt, UInt64 or int e.g. `BigUInt(4) - 2`.

This will error on underflow

<a id="algopy.BigUInt.__xor__"></a>

### \_\_xor_\_

__xor__(other: [algopy.BigUInt](#algopy.BigUInt) | [algopy.UInt64](#algopy.UInt64) | int) → [algopy.BigUInt](#algopy.BigUInt)

A BigUInt can bitwise xor with another BigUInt, UInt64 or int e.g. `BigUInt(4) ^ 2`

<a id="algopy.BigUInt.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.BigUInt.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.Box"></a>

## *class* algopy.Box

Box(type_: type[algopy._TValue], /, \*, key: bytes | str | [algopy.Bytes](#algopy.Bytes) | [algopy.String](#algopy.String) = ...)

Box abstracts the reading and writing of a single value to a single box.
The box size will be reconfigured dynamically to fit the size of the value being assigned to
it.

## Initialization

<a id="algopy.Box.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns True if the box exists, regardless of the truthiness of the contents
of the box

<a id="algopy.Box.get"></a>

### get

get(\*, default: algopy._TValue) → algopy._TValue

Retrieve the contents of the box, or return the default value if the box has not been
created.

:arg default: The default value to return if the box has not been created

<a id="algopy.Box.key"></a>

### *property* key

key *: [algopy.Bytes](#algopy.Bytes)*

Provides access to the raw storage key

<a id="algopy.Box.length"></a>

### *property* length

length *: [algopy.UInt64](#algopy.UInt64)*

Get the length of this Box. Fails if the box does not exist

<a id="algopy.Box.maybe"></a>

### maybe

maybe() → tuple[algopy._TValue, bool]

Retrieve the contents of the box if it exists, and return a boolean indicating if the box
exists.

<a id="algopy.Box.value"></a>

### *property* value

value *: algopy._TValue*

Retrieve the contents of the box. Fails if the box has not been created.

<a id="algopy.BoxMap"></a>

## *class* algopy.BoxMap

BoxMap(key_type: type[algopy._TKey], value_type: type[algopy._TValue], /, \*, key_prefix: bytes | str | [algopy.Bytes](#algopy.Bytes) | [algopy.String](#algopy.String) = ...)

BoxMap abstracts the reading and writing of a set of boxes using a common key and content type.
Each composite key (prefix + key) still needs to be made available to the application via the
`boxes` property of the Transaction.

## Initialization

Declare a box map.

:arg key_type: The type of the keys
:arg value_type: The type of the values
:arg key_prefix: The value used as a prefix to key data, can be empty.
When the BoxMap is being assigned to a member variable,
this argument is optional and defaults to the member variable name,
and if a custom value is supplied it must be static.

<a id="algopy.BoxMap.__contains__"></a>

### \_\_contains_\_

__contains__(key: algopy._TKey) → bool

Returns True if a box with the specified key exists in the map, regardless of the
truthiness of the contents of the box

<a id="algopy.BoxMap.__delitem__"></a>

### \_\_delitem_\_

__delitem__(key: algopy._TKey) → None

Deletes a keyed box

<a id="algopy.BoxMap.__getitem__"></a>

### \_\_getitem_\_

__getitem__(key: algopy._TKey) → algopy._TValue

Retrieve the contents of a keyed box. Fails if the box for the key has not been created.

<a id="algopy.BoxMap.__setitem__"></a>

### \_\_setitem_\_

__setitem__(key: algopy._TKey, value: algopy._TValue) → None

Write *value* to a keyed box. Creates the box if it does not exist

<a id="algopy.BoxMap.get"></a>

### get

get(key: algopy._TKey, \*, default: algopy._TValue) → algopy._TValue

Retrieve the contents of a keyed box, or return the default value if the box has not been
created.

:arg key: The key of the box to get
:arg default: The default value to return if the box has not been created.

<a id="algopy.BoxMap.key_prefix"></a>

### *property* key_prefix

key_prefix *: [algopy.Bytes](#algopy.Bytes)*

Provides access to the raw storage key-prefix

<a id="algopy.BoxMap.length"></a>

### length

length(key: algopy._TKey) → [algopy.UInt64](#algopy.UInt64)

Get the length of an item in this BoxMap. Fails if the box does not exist

:arg key: The key of the box to get

<a id="algopy.BoxMap.maybe"></a>

### maybe

maybe(key: algopy._TKey) → tuple[algopy._TValue, bool]

Retrieve the contents of a keyed box if it exists, and return a boolean indicating if the
box exists.

:arg key: The key of the box to get

<a id="algopy.BoxRef"></a>

## *class* algopy.BoxRef

BoxRef(/, \*, key: bytes | str | algopy.Bytes | algopy.String = ...)

BoxRef abstracts the reading and writing of boxes containing raw binary data. The size is
configured manually, and can be set to values larger than what the AVM can handle in a single
value.

## Initialization

<a id="algopy.BoxRef.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns True if the box has a value set, regardless of the truthiness of that value

<a id="algopy.BoxRef.create"></a>

### create

create(\*, size: [algopy.UInt64](#algopy.UInt64) | int) → bool

Creates a box with the specified size, setting all bits to zero. Fails if the box already
exists with a different size. Fails if the specified size is greater than the max box size
(32,768)

Returns True if the box was created, False if the box already existed

<a id="algopy.BoxRef.delete"></a>

### delete

delete() → bool

Deletes the box if it exists and returns a value indicating if the box existed

<a id="algopy.BoxRef.extract"></a>

### extract

extract(start_index: [algopy.UInt64](#algopy.UInt64) | int, length: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.Bytes](#algopy.Bytes)

Extract a slice of bytes from the box.

Fails if the box does not exist, or if `start_index + length > len(box)`

:arg start_index: The offset to start extracting bytes from
:arg length: The number of bytes to extract

<a id="algopy.BoxRef.get"></a>

### get

get(\*, default: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Retrieve the contents of the box, or return the default value if the box has not been
created.

:arg default: The default value to return if the box has not been created

<a id="algopy.BoxRef.key"></a>

### *property* key

key *: [algopy.Bytes](#algopy.Bytes)*

Provides access to the raw storage key

<a id="algopy.BoxRef.length"></a>

### *property* length

length *: [algopy.UInt64](#algopy.UInt64)*

Get the length of this Box. Fails if the box does not exist

<a id="algopy.BoxRef.maybe"></a>

### maybe

maybe() → tuple[[algopy.Bytes](#algopy.Bytes), bool]

Retrieve the contents of the box if it exists, and return a boolean indicating if the box
exists.

<a id="algopy.BoxRef.put"></a>

### put

put(value: [algopy.Bytes](#algopy.Bytes) | bytes) → None

Replaces the contents of box with value. Fails if box exists and len(box) != len(value).
Creates box if it does not exist

:arg value: The value to write to the box

<a id="algopy.BoxRef.replace"></a>

### replace

replace(start_index: [algopy.UInt64](#algopy.UInt64) | int, value: [algopy.Bytes](#algopy.Bytes) | bytes) → None

Write `value` to the box starting at `start_index`. Fails if the box does not exist,
or if `start_index + len(value) > len(box)`

:arg start_index: The offset to start writing bytes from
:arg value: The bytes to be written

<a id="algopy.BoxRef.resize"></a>

### resize

resize(new_size: [algopy.UInt64](#algopy.UInt64) | int) → None

Resizes the box the specified `new_size`. Truncating existing data if the new value is
shorter or padding with zero bytes if it is longer.

:arg new_size: The new size of the box

<a id="algopy.BoxRef.splice"></a>

### splice

splice(start_index: [algopy.UInt64](#algopy.UInt64) | int, length: [algopy.UInt64](#algopy.UInt64) | int, value: [algopy.Bytes](#algopy.Bytes) | bytes) → None

set box to contain its previous bytes up to index `start_index`, followed by `bytes`,
followed by the original bytes of the box that began at index `start_index + length`

**Important: This op does not resize the box**
If the new value is longer than the box size, it will be truncated.
If the new value is shorter than the box size, it will be padded with zero bytes

:arg start_index: The index to start inserting `value`
:arg length: The number of bytes after `start_index` to omit from the new value
:arg value: The `value` to be inserted.

<a id="algopy.Bytes"></a>

## *class* algopy.Bytes

Bytes(value: bytes = b'', /)

A byte sequence, with a maximum length of 4096 bytes, one of the primary data types on the AVM

## Initialization

Bytes can be initialized with a Python bytes literal, or bytes variable
declared at the module level

<a id="algopy.Bytes.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Concatenate Bytes with another Bytes or bytes literal
e.g. `Bytes(b"Hello ") + b"World"`.

<a id="algopy.Bytes.__and__"></a>

### \_\_and_\_

__and__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Bytes can bitwise and with another Bytes or bytes e.g. `Bytes(b"FF") & b"0F")`

<a id="algopy.Bytes.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if length of bytes is \>0

<a id="algopy.Bytes.__contains__"></a>

### \_\_contains_\_

__contains__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → bool

Test whether another Bytes is a substring of this one.
Note this is expensive due to a lack of AVM support.

<a id="algopy.Bytes.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → bool

Bytes can be compared using the `==` operator with another Bytes or bytes

<a id="algopy.Bytes.__getitem__"></a>

### \_\_getitem_\_

__getitem__(index: [algopy.UInt64](#algopy.UInt64) | int | slice) → [algopy.Bytes](#algopy.Bytes)

Returns a Bytes containing a single byte if indexed with UInt64 or int
otherwise the substring o bytes described by the slice

<a id="algopy.Bytes.__iadd__"></a>

### \_\_iadd_\_

__iadd__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Concatenate Bytes with another Bytes or bytes literal
e.g. `a += Bytes(b"World")`.

<a id="algopy.Bytes.__iand__"></a>

### \_\_iand_\_

__iand__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Bytes can bitwise and with another Bytes or bytes e.g. `a &= Bytes(b"0F")`

<a id="algopy.Bytes.__invert__"></a>

### \_\_invert_\_

__invert__() → [algopy.Bytes](#algopy.Bytes)

Bytes can be bitwise inverted e.g. `~Bytes(b"FF)`

<a id="algopy.Bytes.__ior__"></a>

### \_\_ior_\_

__ior__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Bytes can bitwise or with another Bytes or bytes e.g. `a |= Bytes(b"0F")`

<a id="algopy.Bytes.__iter__"></a>

### \_\_iter_\_

__iter__() → collections.abc.Iterator[[algopy.Bytes](#algopy.Bytes)]

Bytes can be iterated, yielding each consecutive byte

<a id="algopy.Bytes.__ixor__"></a>

### \_\_ixor_\_

__ixor__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Bytes can bitwise xor with another Bytes or bytes e.g. `a ^= Bytes(b"0F")`

<a id="algopy.Bytes.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → bool

Bytes can be compared using the `!=` operator with another Bytes or bytes

<a id="algopy.Bytes.__or__"></a>

### \_\_or_\_

__or__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Bytes can bitwise or with another Bytes or bytes e.g. `Bytes(b"FF") | b"0F")`

<a id="algopy.Bytes.__radd__"></a>

### \_\_radd_\_

__radd__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Concatenate Bytes with another Bytes or bytes literal
e.g. `b"Hello " + Bytes(b"World")`.

<a id="algopy.Bytes.__reversed__"></a>

### \_\_reversed_\_

__reversed__() → collections.abc.Iterator[[algopy.Bytes](#algopy.Bytes)]

Bytes can be iterated in reverse, yield each preceding byte starting at the end

<a id="algopy.Bytes.__xor__"></a>

### \_\_xor_\_

__xor__(other: [algopy.Bytes](#algopy.Bytes) | bytes) → [algopy.Bytes](#algopy.Bytes)

Bytes can bitwise xor with another Bytes or bytes e.g. `Bytes(b"FF") ^ b"0F")`

<a id="algopy.Bytes.from_base32"></a>

### *static* from_base32

from_base32(value: str, /) → [algopy.Bytes](#algopy.Bytes)

Creates Bytes from a base32 encoded string e.g. `Bytes.from_base32("74======")`

<a id="algopy.Bytes.from_base64"></a>

### *static* from_base64

from_base64(value: str, /) → [algopy.Bytes](#algopy.Bytes)

Creates Bytes from a base64 encoded string e.g. `Bytes.from_base64("RkY=")`

<a id="algopy.Bytes.from_hex"></a>

### *static* from_hex

from_hex(value: str, /) → [algopy.Bytes](#algopy.Bytes)

Creates Bytes from a hex/octal encoded string e.g. `Bytes.from_hex("FF")`

<a id="algopy.Bytes.length"></a>

### *property* length

length *: [algopy.UInt64](#algopy.UInt64)*

Returns the length of the Bytes

<a id="algopy.BytesBacked"></a>

## *class* algopy.BytesBacked

BytesBacked

Represents a type that is a single bytes value

<a id="algopy.BytesBacked.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.BytesBacked.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.CompiledContract"></a>

## *class* algopy.CompiledContract

CompiledContract

Provides compiled programs and state allocation values for a Contract.
Create by calling [`compile_contract`](#algopy.compile_contract).

<a id="algopy.CompiledContract.approval_program"></a>

### approval_program

approval_program *: tuple[[algopy.Bytes](#algopy.Bytes), [algopy.Bytes](#algopy.Bytes)]*

None

Approval program pages for a contract, after template variables have been replaced
and compiled to AVM bytecode

<a id="algopy.CompiledContract.clear_state_program"></a>

### clear_state_program

clear_state_program *: tuple[[algopy.Bytes](#algopy.Bytes), [algopy.Bytes](#algopy.Bytes)]*

None

Clear state program pages for a contract, after template variables have been replaced
and compiled to AVM bytecode

<a id="algopy.CompiledContract.extra_program_pages"></a>

### extra_program_pages

extra_program_pages *: [algopy.UInt64](#algopy.UInt64)*

None

By default, provides extra program pages required based on approval and clear state program
size, can be overridden when calling compile_contract

<a id="algopy.CompiledContract.global_bytes"></a>

### global_bytes

global_bytes *: [algopy.UInt64](#algopy.UInt64)*

None

By default, provides global num bytes based on contract state totals, can be overridden
when calling compile_contract

<a id="algopy.CompiledContract.global_uints"></a>

### global_uints

global_uints *: [algopy.UInt64](#algopy.UInt64)*

None

By default, provides global num uints based on contract state totals, can be overridden
when calling compile_contract

<a id="algopy.CompiledContract.local_bytes"></a>

### local_bytes

local_bytes *: [algopy.UInt64](#algopy.UInt64)*

None

By default, provides local num bytes based on contract state totals, can be overridden
when calling compile_contract

<a id="algopy.CompiledContract.local_uints"></a>

### local_uints

local_uints *: [algopy.UInt64](#algopy.UInt64)*

None

By default, provides local num uints based on contract state totals, can be overridden
when calling compile_contract

<a id="algopy.CompiledLogicSig"></a>

## *class* algopy.CompiledLogicSig

CompiledLogicSig

Provides account for a Logic Signature.
Create by calling [`compile_logicsig`](#algopy.compile_logicsig).

<a id="algopy.CompiledLogicSig.account"></a>

### account

account *: [algopy.Account](#algopy.Account)*

None

Address of a logic sig program, after template variables have been replaced and compiled
to AVM bytecode

<a id="algopy.Contract"></a>

## *class* algopy.Contract

Contract

Base class for an Algorand Smart Contract

<a id="algopy.Contract.__init_subclass__"></a>

### *classmethod* \_\_init_subclass_\_

__init_subclass__(\*, name: str = ..., scratch_slots: [algopy.urange](#algopy.urange) | tuple[int | [algopy.urange](#algopy.urange), ...] | list[int | [algopy.urange](#algopy.urange)] = ..., state_totals: [algopy.StateTotals](#algopy.StateTotals) = ..., avm_version: int = ...)

When declaring a Contract subclass, options and configuration are passed in
the base class list:

```python
class MyContract(algopy.Contract, name="CustomName"):
    ...
```

:param name:
Will affect the output TEAL file name if there are multiple non-abstract contracts
in the same file.

If the contract is a subclass of algopy.ARC4Contract, `name` will also be used as the
contract name in the ARC-32 application.json, instead of the class name.

:param scratch_slots:
Allows you to mark a slot ID or range of slot IDs as “off limits” to Puya.
These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.
This is particularly useful in combination with `algopy.op.gload_bytes` / `algopy.op.gload_uint64`
which lets a contract in a group transaction read from the scratch slots of another contract
that occurs earlier in the transaction group.

In the case of inheritance, scratch slots reserved become cumulative. It is not an error
to have overlapping ranges or values either, so if a base class contract reserves slots
0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived
contract all slots 0-10 will be marked as reserved.

:param state_totals:
Allows defining what values should be used for global and local uint and bytes storage
values when creating a contract. Used when outputting ARC-32 application.json schemas.

If let unspecified, the totals will be determined by the compiler based on state
variables assigned to `self`.

This setting is not inherited, and only applies to the exact `Contract` it is specified
on. If a base class does specify this setting, and a derived class does not, a warning
will be emitted for the derived class. To resolve this warning, `state_totals` must be
specified. Note that it is valid to not provide any arguments to the `StateTotals`
constructor, like so `state_totals=StateTotals()`, in which case all values will be
automatically calculated.
:param avm_version:
Determines which AVM version to use, this affects what operations are supported.
Defaults to value provided supplied on command line (which defaults to current mainnet version)

<a id="algopy.Contract.approval_program"></a>

### *abstract* approval_program

approval_program() → [algopy.UInt64](#algopy.UInt64) | bool

Represents the program called for all transactions
where `OnCompletion` != `ClearState`

<a id="algopy.Contract.clear_state_program"></a>

### *abstract* clear_state_program

clear_state_program() → [algopy.UInt64](#algopy.UInt64) | bool

Represents the program called when `OnCompletion` == `ClearState`

<a id="algopy.Global"></a>

## *class* algopy.Global

Global

Get Global values
Native TEAL op: [`global`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#global)

<a id="algopy.Global.asset_create_min_balance"></a>

### asset_create_min_balance

asset_create_min_balance *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The additional minimum balance required to create (and opt-in to) an asset.

<a id="algopy.Global.asset_opt_in_min_balance"></a>

### asset_opt_in_min_balance

asset_opt_in_min_balance *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The additional minimum balance required to opt-in to an asset.

<a id="algopy.Global.caller_application_address"></a>

### caller_application_address

caller_application_address *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

The application address of the application that called this application. ZeroAddress if this application is at the top-level. Application mode only.

<a id="algopy.Global.caller_application_id"></a>

### caller_application_id

caller_application_id *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The application ID of the application that called this application. 0 if this application is at the top-level. Application mode only.

<a id="algopy.Global.creator_address"></a>

### creator_address

creator_address *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

Address of the creator of the current application. Application mode only.

<a id="algopy.Global.current_application_address"></a>

### current_application_address

current_application_address *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

Address that the current application controls. Application mode only.

<a id="algopy.Global.current_application_id"></a>

### current_application_id

current_application_id *: Final[[algopy.Application](#algopy.Application)]*

Ellipsis

ID of current application executing. Application mode only.

<a id="algopy.Global.genesis_hash"></a>

### genesis_hash

genesis_hash *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

The Genesis Hash for the network.

<a id="algopy.Global.group_id"></a>

### group_id

group_id *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

ID of the transaction group. 32 zero bytes if the transaction is not part of a group.

<a id="algopy.Global.group_size"></a>

### group_size

group_size *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of transactions in this atomic transaction group. At least 1

<a id="algopy.Global.latest_timestamp"></a>

### latest_timestamp

latest_timestamp *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Last confirmed block UNIX timestamp. Fails if negative. Application mode only.

<a id="algopy.Global.logic_sig_version"></a>

### logic_sig_version

logic_sig_version *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Maximum supported version

<a id="algopy.Global.max_txn_life"></a>

### max_txn_life

max_txn_life *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

rounds

<a id="algopy.Global.min_balance"></a>

### min_balance

min_balance *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

microalgos

<a id="algopy.Global.min_txn_fee"></a>

### min_txn_fee

min_txn_fee *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

microalgos

<a id="algopy.Global.opcode_budget"></a>

### *static* opcode_budget

opcode_budget() → [algopy.UInt64](#algopy.UInt64)

The remaining cost that can be spent by opcodes in this program.

Native TEAL opcode: [`global`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#global)

<a id="algopy.Global.payouts_enabled"></a>

### payouts_enabled

payouts_enabled *: Final[bool]*

Ellipsis

Whether block proposal payouts are enabled.
Min AVM version: 11

<a id="algopy.Global.payouts_go_online_fee"></a>

### payouts_go_online_fee

payouts_go_online_fee *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The fee required in a keyreg transaction to make an account incentive eligible.
Min AVM version: 11

<a id="algopy.Global.payouts_max_balance"></a>

### payouts_max_balance

payouts_max_balance *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The maximum algo balance an account can have in the agreement round to receive block payouts in the proposal round.
Min AVM version: 11

<a id="algopy.Global.payouts_min_balance"></a>

### payouts_min_balance

payouts_min_balance *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The minimum algo balance an account must have in the agreement round to receive block payouts in the proposal round.
Min AVM version: 11

<a id="algopy.Global.payouts_percent"></a>

### payouts_percent

payouts_percent *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The percentage of transaction fees in a block that can be paid to the block proposer.
Min AVM version: 11

<a id="algopy.Global.round"></a>

### round

round *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Current round number. Application mode only.

<a id="algopy.Global.zero_address"></a>

### zero_address

zero_address *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address of all zero bytes

<a id="algopy.GlobalState"></a>

## *class* algopy.GlobalState

GlobalState

Global state associated with the application, the key will be the name of the member, this
is assigned to

<Aside type="note" title="Note">The `GlobalState` class provides a richer API that in addition to storing and retrieving
values, can test if a value is set or unset it. However if this extra functionality is not
needed then it is simpler to just store the data without the GlobalState proxy
e.g. `self.some_variable = UInt64(0)`</Aside>

<a id="algopy.GlobalState.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if the key has a value set, regardless of the truthiness of that value

<a id="algopy.GlobalState.get"></a>

### get

get(default: algopy._TState) → algopy._TState

Returns the value or `default` if no value is set

```python
name = self.name.get(Bytes(b"no name")
```

<a id="algopy.GlobalState.key"></a>

### *property* key

key *: [algopy.Bytes](#algopy.Bytes)*

Provides access to the raw storage key

<a id="algopy.GlobalState.maybe"></a>

### maybe

maybe() → tuple[algopy._TState, bool]

Returns the value, and a bool

```python
name, name_exists = self.name.maybe()
if not name_exists:
    name = Bytes(b"no name")
```

<a id="algopy.GlobalState.value"></a>

### *property* value

value *: algopy._TState*

Returns the value or and error if the value is not set

```python
name = self.name.value
```

<a id="algopy.LocalState"></a>

## *class* algopy.LocalState

LocalState(type_: type[algopy._TState], /, \*, key: [algopy.String](#algopy.String) | [algopy.Bytes](#algopy.Bytes) | bytes | str = ..., description: str = '')

Local state associated with the application and an account

## Initialization

Declare the local state key and it’s associated type

```python
self.names = LocalState(algopy.Bytes)
```

<a id="algopy.LocalState.__contains__"></a>

### \_\_contains_\_

__contains__(account: [algopy.Account](#algopy.Account) | [algopy.UInt64](#algopy.UInt64) | int) → bool

Can test if data exists by using an `Account` reference or foreign account index

```python
assert account in self.names
```

<a id="algopy.LocalState.__delitem__"></a>

### \_\_delitem_\_

__delitem__(account: [algopy.Account](#algopy.Account) | [algopy.UInt64](#algopy.UInt64) | int) → None

Data can be removed by using an `Account` reference or foreign account index

```python
del self.names[account]
```

<a id="algopy.LocalState.__getitem__"></a>

### \_\_getitem_\_

__getitem__(account: [algopy.Account](#algopy.Account) | [algopy.UInt64](#algopy.UInt64) | int) → algopy._TState

Data can be accessed by an `Account` reference or foreign account index

```python
account_name = self.names[account]
```

<a id="algopy.LocalState.__setitem__"></a>

### \_\_setitem_\_

__setitem__(account: [algopy.Account](#algopy.Account) | [algopy.UInt64](#algopy.UInt64) | int, value: algopy._TState) → None

Data can be stored by using an `Account` reference or foreign account index

```python
self.names[account] = account_name
```

<a id="algopy.LocalState.get"></a>

### get

get(account: [algopy.Account](#algopy.Account) | [algopy.UInt64](#algopy.UInt64) | int, default: algopy._TState) → algopy._TState

Can retrieve value using an `Account` reference or foreign account index,
and a fallback default value.

```python
name = self.names.get(account, Bytes(b"no name")
```

<a id="algopy.LocalState.key"></a>

### *property* key

key *: [algopy.Bytes](#algopy.Bytes)*

Provides access to the raw storage key

<a id="algopy.LocalState.maybe"></a>

### maybe

maybe(account: [algopy.Account](#algopy.Account) | [algopy.UInt64](#algopy.UInt64) | int) → tuple[algopy._TState, bool]

Can retrieve value, and a bool indicating if the value was present
using an `Account` reference or foreign account index.

```python
name, name_exists = self.names.maybe(account)
if not name_exists:
    name = Bytes(b"no name")
```

<a id="algopy.LogicSig"></a>

## *class* algopy.LogicSig

LogicSig

A logic signature

<a id="algopy.OnCompleteAction"></a>

## *class* algopy.OnCompleteAction

OnCompleteAction(value: int = 0, /)

On Completion actions available in an application call transaction

## Initialization

A UInt64 can be initialized with a Python int literal, or an int variable
declared at the module level

<a id="algopy.OnCompleteAction.ClearState"></a>

### ClearState

ClearState *: [algopy.OnCompleteAction](#algopy.OnCompleteAction)*

Ellipsis

ClearState is similar to CloseOut, but may never fail. This
allows users to reclaim their minimum balance from an application
they no longer wish to opt in to.

<a id="algopy.OnCompleteAction.CloseOut"></a>

### CloseOut

CloseOut *: [algopy.OnCompleteAction](#algopy.OnCompleteAction)*

Ellipsis

CloseOut indicates that an application transaction will deallocate
some LocalState for the application from the user’s account

<a id="algopy.OnCompleteAction.DeleteApplication"></a>

### DeleteApplication

DeleteApplication *: [algopy.OnCompleteAction](#algopy.OnCompleteAction)*

Ellipsis

DeleteApplication indicates that an application transaction will
delete the AppParams for the application from the creator’s balance
record

<a id="algopy.OnCompleteAction.NoOp"></a>

### NoOp

NoOp *: [algopy.OnCompleteAction](#algopy.OnCompleteAction)*

Ellipsis

NoOP indicates that no additional action is performed when the transaction completes

<a id="algopy.OnCompleteAction.OptIn"></a>

### OptIn

OptIn *: [algopy.OnCompleteAction](#algopy.OnCompleteAction)*

Ellipsis

OptIn indicates that an application transaction will allocate some
LocalState for the application in the sender’s account

<a id="algopy.OnCompleteAction.UpdateApplication"></a>

### UpdateApplication

UpdateApplication *: [algopy.OnCompleteAction](#algopy.OnCompleteAction)*

Ellipsis

UpdateApplication indicates that an application transaction will
update the ApprovalProgram and ClearStateProgram for the application

<a id="algopy.OnCompleteAction.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `UInt(4) + 2`.

This will error on overflow

<a id="algopy.OnCompleteAction.__and__"></a>

### \_\_and_\_

__and__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `UInt64(4) & 2`

<a id="algopy.OnCompleteAction.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

A UInt64 will evaluate to `False` if zero, and `True` otherwise

<a id="algopy.OnCompleteAction.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `==` operator with another UInt64 or int

<a id="algopy.OnCompleteAction.__floordiv__"></a>

### \_\_floordiv_\_

__floordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `UInt64(4) // 2`.

This will error on divide by zero

<a id="algopy.OnCompleteAction.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>=` operator with another UInt64 or int

<a id="algopy.OnCompleteAction.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>` operator with another UInt64 or int

<a id="algopy.OnCompleteAction.__iadd__"></a>

### \_\_iadd_\_

__iadd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be incremented with another UInt64 or int e.g. `a += UInt(2)`.

This will error on overflow

<a id="algopy.OnCompleteAction.__iand__"></a>

### \_\_iand_\_

__iand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `a &= UInt64(2)`

<a id="algopy.OnCompleteAction.__ifloordiv__"></a>

### \_\_ifloordiv_\_

__ifloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `a //= UInt64(2)`.

This will error on divide by zero

<a id="algopy.OnCompleteAction.__ilshift__"></a>

### \_\_ilshift_\_

__ilshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `a <<= UInt64(2)`

<a id="algopy.OnCompleteAction.__imod__"></a>

### \_\_imod_\_

__imod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `a %= UInt64(2)`.

This will error on mod by zero

<a id="algopy.OnCompleteAction.__imul__"></a>

### \_\_imul_\_

__imul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `a*= UInt64(2)`.

This will error on overflow

<a id="algopy.OnCompleteAction.__index__"></a>

### \_\_index_\_

__index__() → int

A UInt64 can be used in indexing/slice expressions

<a id="algopy.OnCompleteAction.__invert__"></a>

### \_\_invert_\_

__invert__() → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be bitwise inverted e.g. `~UInt64(4)`

<a id="algopy.OnCompleteAction.__ior__"></a>

### \_\_ior_\_

__ior__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `a |= UInt64(2)`

<a id="algopy.OnCompleteAction.__ipow__"></a>

### \_\_ipow_\_

__ipow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `a **= UInt64(2)`.

This will error on overflow

<a id="algopy.OnCompleteAction.__irshift__"></a>

### \_\_irshift_\_

__irshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `a >>= UInt64(2)`

<a id="algopy.OnCompleteAction.__isub__"></a>

### \_\_isub_\_

__isub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `a -= UInt64(2)`.

This will error on underflow

<a id="algopy.OnCompleteAction.__ixor__"></a>

### \_\_ixor_\_

__ixor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `a ^= UInt64(2)`

<a id="algopy.OnCompleteAction.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<=` operator with another UInt64 or int

<a id="algopy.OnCompleteAction.__lshift__"></a>

### \_\_lshift_\_

__lshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `UInt64(4) << 2`

<a id="algopy.OnCompleteAction.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<` operator with another UInt64 or int

<a id="algopy.OnCompleteAction.__mod__"></a>

### \_\_mod_\_

__mod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `UInt64(4) % 2`.

This will error on mod by zero

<a id="algopy.OnCompleteAction.__mul__"></a>

### \_\_mul_\_

__mul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.OnCompleteAction.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `!=` operator with another UInt64 or int

<a id="algopy.OnCompleteAction.__or__"></a>

### \_\_or_\_

__or__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `UInt64(4) | 2`

<a id="algopy.OnCompleteAction.__pos__"></a>

### \_\_pos_\_

__pos__() → [algopy.UInt64](#algopy.UInt64)

Supports unary + operator. Redundant given the type is unsigned

<a id="algopy.OnCompleteAction.__pow__"></a>

### \_\_pow_\_

__pow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `UInt64(4) ** 2`.

This will error on overflow

<a id="algopy.OnCompleteAction.__radd__"></a>

### \_\_radd_\_

__radd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.OnCompleteAction.__rand__"></a>

### \_\_rand_\_

__rand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `4 & UInt64(2)`

<a id="algopy.OnCompleteAction.__rfloordiv__"></a>

### \_\_rfloordiv_\_

__rfloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `4 // UInt64(2)`.

This will error on divide by zero

<a id="algopy.OnCompleteAction.__rlshift__"></a>

### \_\_rlshift_\_

__rlshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `4 << UInt64(2)`

<a id="algopy.OnCompleteAction.__rmod__"></a>

### \_\_rmod_\_

__rmod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `4 % UInt64(2)`.

This will error on mod by zero

<a id="algopy.OnCompleteAction.__rmul__"></a>

### \_\_rmul_\_

__rmul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `UInt64(4) + 2`.

This will error on overflow

<a id="algopy.OnCompleteAction.__ror__"></a>

### \_\_ror_\_

__ror__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `4 | UInt64(2)`

<a id="algopy.OnCompleteAction.__rpow__"></a>

### \_\_rpow_\_

__rpow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `4 ** UInt64(2)`.

This will error on overflow

<a id="algopy.OnCompleteAction.__rrshift__"></a>

### \_\_rrshift_\_

__rrshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `4 >> UInt64(2)`

<a id="algopy.OnCompleteAction.__rshift__"></a>

### \_\_rshift_\_

__rshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `UInt64(4) >> 2`

<a id="algopy.OnCompleteAction.__rsub__"></a>

### \_\_rsub_\_

__rsub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `4 - UInt64(2)`.

This will error on underflow

<a id="algopy.OnCompleteAction.__rxor__"></a>

### \_\_rxor_\_

__rxor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `4 ^ UInt64(2)`

<a id="algopy.OnCompleteAction.__sub__"></a>

### \_\_sub_\_

__sub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `UInt(4) - 2`.

This will error on underflow

<a id="algopy.OnCompleteAction.__xor__"></a>

### \_\_xor_\_

__xor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `UInt64(4) ^ 2`

<a id="algopy.OpUpFeeSource"></a>

## *class* algopy.OpUpFeeSource

OpUpFeeSource(value: int = 0, /)

Defines the source of fees for the OpUp utility.

## Initialization

A UInt64 can be initialized with a Python int literal, or an int variable
declared at the module level

<a id="algopy.OpUpFeeSource.Any"></a>

### Any

Any *: [algopy.OpUpFeeSource](#algopy.OpUpFeeSource)*

Ellipsis

First the excess will be used, remaining fees will be taken from the app account

<a id="algopy.OpUpFeeSource.AppAccount"></a>

### AppAccount

AppAccount *: [algopy.OpUpFeeSource](#algopy.OpUpFeeSource)*

Ellipsis

The app’s account will cover all fees (set inner_tx.fee=Global.min_tx_fee())

<a id="algopy.OpUpFeeSource.GroupCredit"></a>

### GroupCredit

GroupCredit *: [algopy.OpUpFeeSource](#algopy.OpUpFeeSource)*

Ellipsis

Only the excess fee (credit) on the outer group should be used (set inner_tx.fee=0)

<a id="algopy.OpUpFeeSource.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `UInt(4) + 2`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__and__"></a>

### \_\_and_\_

__and__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `UInt64(4) & 2`

<a id="algopy.OpUpFeeSource.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

A UInt64 will evaluate to `False` if zero, and `True` otherwise

<a id="algopy.OpUpFeeSource.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `==` operator with another UInt64 or int

<a id="algopy.OpUpFeeSource.__floordiv__"></a>

### \_\_floordiv_\_

__floordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `UInt64(4) // 2`.

This will error on divide by zero

<a id="algopy.OpUpFeeSource.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>=` operator with another UInt64 or int

<a id="algopy.OpUpFeeSource.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>` operator with another UInt64 or int

<a id="algopy.OpUpFeeSource.__iadd__"></a>

### \_\_iadd_\_

__iadd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be incremented with another UInt64 or int e.g. `a += UInt(2)`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__iand__"></a>

### \_\_iand_\_

__iand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `a &= UInt64(2)`

<a id="algopy.OpUpFeeSource.__ifloordiv__"></a>

### \_\_ifloordiv_\_

__ifloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `a //= UInt64(2)`.

This will error on divide by zero

<a id="algopy.OpUpFeeSource.__ilshift__"></a>

### \_\_ilshift_\_

__ilshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `a <<= UInt64(2)`

<a id="algopy.OpUpFeeSource.__imod__"></a>

### \_\_imod_\_

__imod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `a %= UInt64(2)`.

This will error on mod by zero

<a id="algopy.OpUpFeeSource.__imul__"></a>

### \_\_imul_\_

__imul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `a*= UInt64(2)`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__index__"></a>

### \_\_index_\_

__index__() → int

A UInt64 can be used in indexing/slice expressions

<a id="algopy.OpUpFeeSource.__invert__"></a>

### \_\_invert_\_

__invert__() → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be bitwise inverted e.g. `~UInt64(4)`

<a id="algopy.OpUpFeeSource.__ior__"></a>

### \_\_ior_\_

__ior__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `a |= UInt64(2)`

<a id="algopy.OpUpFeeSource.__ipow__"></a>

### \_\_ipow_\_

__ipow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `a **= UInt64(2)`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__irshift__"></a>

### \_\_irshift_\_

__irshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `a >>= UInt64(2)`

<a id="algopy.OpUpFeeSource.__isub__"></a>

### \_\_isub_\_

__isub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `a -= UInt64(2)`.

This will error on underflow

<a id="algopy.OpUpFeeSource.__ixor__"></a>

### \_\_ixor_\_

__ixor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `a ^= UInt64(2)`

<a id="algopy.OpUpFeeSource.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<=` operator with another UInt64 or int

<a id="algopy.OpUpFeeSource.__lshift__"></a>

### \_\_lshift_\_

__lshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `UInt64(4) << 2`

<a id="algopy.OpUpFeeSource.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<` operator with another UInt64 or int

<a id="algopy.OpUpFeeSource.__mod__"></a>

### \_\_mod_\_

__mod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `UInt64(4) % 2`.

This will error on mod by zero

<a id="algopy.OpUpFeeSource.__mul__"></a>

### \_\_mul_\_

__mul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `!=` operator with another UInt64 or int

<a id="algopy.OpUpFeeSource.__or__"></a>

### \_\_or_\_

__or__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `UInt64(4) | 2`

<a id="algopy.OpUpFeeSource.__pos__"></a>

### \_\_pos_\_

__pos__() → [algopy.UInt64](#algopy.UInt64)

Supports unary + operator. Redundant given the type is unsigned

<a id="algopy.OpUpFeeSource.__pow__"></a>

### \_\_pow_\_

__pow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `UInt64(4) ** 2`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__radd__"></a>

### \_\_radd_\_

__radd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__rand__"></a>

### \_\_rand_\_

__rand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `4 & UInt64(2)`

<a id="algopy.OpUpFeeSource.__rfloordiv__"></a>

### \_\_rfloordiv_\_

__rfloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `4 // UInt64(2)`.

This will error on divide by zero

<a id="algopy.OpUpFeeSource.__rlshift__"></a>

### \_\_rlshift_\_

__rlshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `4 << UInt64(2)`

<a id="algopy.OpUpFeeSource.__rmod__"></a>

### \_\_rmod_\_

__rmod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `4 % UInt64(2)`.

This will error on mod by zero

<a id="algopy.OpUpFeeSource.__rmul__"></a>

### \_\_rmul_\_

__rmul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `UInt64(4) + 2`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__ror__"></a>

### \_\_ror_\_

__ror__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `4 | UInt64(2)`

<a id="algopy.OpUpFeeSource.__rpow__"></a>

### \_\_rpow_\_

__rpow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `4 ** UInt64(2)`.

This will error on overflow

<a id="algopy.OpUpFeeSource.__rrshift__"></a>

### \_\_rrshift_\_

__rrshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `4 >> UInt64(2)`

<a id="algopy.OpUpFeeSource.__rshift__"></a>

### \_\_rshift_\_

__rshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `UInt64(4) >> 2`

<a id="algopy.OpUpFeeSource.__rsub__"></a>

### \_\_rsub_\_

__rsub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `4 - UInt64(2)`.

This will error on underflow

<a id="algopy.OpUpFeeSource.__rxor__"></a>

### \_\_rxor_\_

__rxor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `4 ^ UInt64(2)`

<a id="algopy.OpUpFeeSource.__sub__"></a>

### \_\_sub_\_

__sub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `UInt(4) - 2`.

This will error on underflow

<a id="algopy.OpUpFeeSource.__xor__"></a>

### \_\_xor_\_

__xor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `UInt64(4) ^ 2`

<a id="algopy.StateTotals"></a>

## *class* algopy.StateTotals

StateTotals(\*, global_uints: int = ..., global_bytes: int = ..., local_uints: int = ..., local_bytes: int = ...)

Options class to manually define the total amount of global and local state contract will use,
used by [`Contract.__init_subclass__`](#algopy.Contract.__init_subclass__).

This is not required when all state is assigned to `self.`, but is required if a
contract dynamically interacts with state via `AppGlobal.get_bytes` etc, or if you want
to reserve additional state storage for future contract updates, since the Algorand protocol
doesn’t allow increasing them after creation.

## Initialization

Specify the totals for both global and local, and for each type. Any arguments not
specified default to their automatically calculated values.

Values are validated against the known totals assigned through `self.`, a warning is
produced if the total specified is insufficient to accommodate all `self.` state values
at once.

<a id="algopy.String"></a>

## *class* algopy.String

String(value: str = '', /)

A UTF-8 encoded string.

In comparison to `arc4.String`, this type does not store the array length prefix, since that
information is always available through the `len` AVM op. This makes it more efficient to
operate on when doing operations such as concatenation.

Note that due to the lack of UTF-8 support in the AVM, indexing and length operations are not
currently supported.

## Initialization

A String can be initialized with a Python `str` literal, or a `str` variable
declared at the module level

<a id="algopy.String.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.String](#algopy.String) | str) → [algopy.String](#algopy.String)

Concatenate `String` with another `String` or `str` literal
e.g. `String("Hello ") + "World"`.

<a id="algopy.String.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if the string is not empty

<a id="algopy.String.__contains__"></a>

### \_\_contains_\_

__contains__(other: [algopy.String](#algopy.String) | str) → bool

Test whether another string is a substring of this one.
Note this is expensive due to a lack of AVM support.

<a id="algopy.String.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.String](#algopy.String) | str) → bool

Supports using the `==` operator with another `String` or literal `str`

<a id="algopy.String.__iadd__"></a>

### \_\_iadd_\_

__iadd__(other: [algopy.String](#algopy.String) | str) → [algopy.String](#algopy.String)

Concatenate `String` with another `String` or `str` literal
e.g. `a = String("Hello"); a += "World"`.

<a id="algopy.String.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.String](#algopy.String) | str) → bool

Supports using the `!=` operator with another `String` or literal `str`

<a id="algopy.String.__radd__"></a>

### \_\_radd_\_

__radd__(other: [algopy.String](#algopy.String) | str) → [algopy.String](#algopy.String)

Concatenate String with another `String` or `str` literal
e.g. `"Hello " + String("World")`.

<a id="algopy.String.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.String.endswith"></a>

### endswith

endswith(suffix: [algopy.String](#algopy.String) | str) → bool

Check if this string ends with another string.

The behaviour should mirror `str.endswith`, for example, if `suffix` is the empty string,
the result will always be `True`.

Only a single argument is currently supported.

<a id="algopy.String.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.String.join"></a>

### join

join(others: tuple[[algopy.String](#algopy.String) | str, ...], /) → [algopy.String](#algopy.String)

Join a sequence of Strings with a common separator.

The behaviour should mirror `str.join`.

<a id="algopy.String.startswith"></a>

### startswith

startswith(prefix: [algopy.String](#algopy.String) | str) → bool

Check if this string starts with another string.

The behaviour should mirror `str.startswith`, for example, if `prefix` is the empty string,
the result will always be `True`.

Only a single argument is currently supported.

<a id="algopy.TemplateVar"></a>

## algopy.TemplateVar

TemplateVar *: algopy._TemplateVarGeneric*

Ellipsis

Template variables can be used to represent a placeholder for a deploy-time provided value.

<a id="algopy.TransactionType"></a>

## *class* algopy.TransactionType

TransactionType(value: int = 0, /)

The different transaction types available in a transaction

## Initialization

A UInt64 can be initialized with a Python int literal, or an int variable
declared at the module level

<a id="algopy.TransactionType.ApplicationCall"></a>

### ApplicationCall

ApplicationCall *: [algopy.TransactionType](#algopy.TransactionType)*

Ellipsis

An Application Call transaction

<a id="algopy.TransactionType.AssetConfig"></a>

### AssetConfig

AssetConfig *: [algopy.TransactionType](#algopy.TransactionType)*

Ellipsis

An Asset Config transaction

<a id="algopy.TransactionType.AssetFreeze"></a>

### AssetFreeze

AssetFreeze *: [algopy.TransactionType](#algopy.TransactionType)*

Ellipsis

An Asset Freeze transaction

<a id="algopy.TransactionType.AssetTransfer"></a>

### AssetTransfer

AssetTransfer *: [algopy.TransactionType](#algopy.TransactionType)*

Ellipsis

An Asset Transfer transaction

<a id="algopy.TransactionType.KeyRegistration"></a>

### KeyRegistration

KeyRegistration *: [algopy.TransactionType](#algopy.TransactionType)*

Ellipsis

A Key Registration transaction

<a id="algopy.TransactionType.Payment"></a>

### Payment

Payment *: [algopy.TransactionType](#algopy.TransactionType)*

Ellipsis

A Payment transaction

<a id="algopy.TransactionType.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `UInt(4) + 2`.

This will error on overflow

<a id="algopy.TransactionType.__and__"></a>

### \_\_and_\_

__and__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `UInt64(4) & 2`

<a id="algopy.TransactionType.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

A UInt64 will evaluate to `False` if zero, and `True` otherwise

<a id="algopy.TransactionType.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `==` operator with another UInt64 or int

<a id="algopy.TransactionType.__floordiv__"></a>

### \_\_floordiv_\_

__floordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `UInt64(4) // 2`.

This will error on divide by zero

<a id="algopy.TransactionType.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>=` operator with another UInt64 or int

<a id="algopy.TransactionType.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>` operator with another UInt64 or int

<a id="algopy.TransactionType.__iadd__"></a>

### \_\_iadd_\_

__iadd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be incremented with another UInt64 or int e.g. `a += UInt(2)`.

This will error on overflow

<a id="algopy.TransactionType.__iand__"></a>

### \_\_iand_\_

__iand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `a &= UInt64(2)`

<a id="algopy.TransactionType.__ifloordiv__"></a>

### \_\_ifloordiv_\_

__ifloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `a //= UInt64(2)`.

This will error on divide by zero

<a id="algopy.TransactionType.__ilshift__"></a>

### \_\_ilshift_\_

__ilshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `a <<= UInt64(2)`

<a id="algopy.TransactionType.__imod__"></a>

### \_\_imod_\_

__imod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `a %= UInt64(2)`.

This will error on mod by zero

<a id="algopy.TransactionType.__imul__"></a>

### \_\_imul_\_

__imul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `a*= UInt64(2)`.

This will error on overflow

<a id="algopy.TransactionType.__index__"></a>

### \_\_index_\_

__index__() → int

A UInt64 can be used in indexing/slice expressions

<a id="algopy.TransactionType.__invert__"></a>

### \_\_invert_\_

__invert__() → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be bitwise inverted e.g. `~UInt64(4)`

<a id="algopy.TransactionType.__ior__"></a>

### \_\_ior_\_

__ior__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `a |= UInt64(2)`

<a id="algopy.TransactionType.__ipow__"></a>

### \_\_ipow_\_

__ipow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `a **= UInt64(2)`.

This will error on overflow

<a id="algopy.TransactionType.__irshift__"></a>

### \_\_irshift_\_

__irshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `a >>= UInt64(2)`

<a id="algopy.TransactionType.__isub__"></a>

### \_\_isub_\_

__isub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `a -= UInt64(2)`.

This will error on underflow

<a id="algopy.TransactionType.__ixor__"></a>

### \_\_ixor_\_

__ixor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `a ^= UInt64(2)`

<a id="algopy.TransactionType.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<=` operator with another UInt64 or int

<a id="algopy.TransactionType.__lshift__"></a>

### \_\_lshift_\_

__lshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `UInt64(4) << 2`

<a id="algopy.TransactionType.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<` operator with another UInt64 or int

<a id="algopy.TransactionType.__mod__"></a>

### \_\_mod_\_

__mod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `UInt64(4) % 2`.

This will error on mod by zero

<a id="algopy.TransactionType.__mul__"></a>

### \_\_mul_\_

__mul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.TransactionType.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `!=` operator with another UInt64 or int

<a id="algopy.TransactionType.__or__"></a>

### \_\_or_\_

__or__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `UInt64(4) | 2`

<a id="algopy.TransactionType.__pos__"></a>

### \_\_pos_\_

__pos__() → [algopy.UInt64](#algopy.UInt64)

Supports unary + operator. Redundant given the type is unsigned

<a id="algopy.TransactionType.__pow__"></a>

### \_\_pow_\_

__pow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `UInt64(4) ** 2`.

This will error on overflow

<a id="algopy.TransactionType.__radd__"></a>

### \_\_radd_\_

__radd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.TransactionType.__rand__"></a>

### \_\_rand_\_

__rand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `4 & UInt64(2)`

<a id="algopy.TransactionType.__rfloordiv__"></a>

### \_\_rfloordiv_\_

__rfloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `4 // UInt64(2)`.

This will error on divide by zero

<a id="algopy.TransactionType.__rlshift__"></a>

### \_\_rlshift_\_

__rlshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `4 << UInt64(2)`

<a id="algopy.TransactionType.__rmod__"></a>

### \_\_rmod_\_

__rmod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `4 % UInt64(2)`.

This will error on mod by zero

<a id="algopy.TransactionType.__rmul__"></a>

### \_\_rmul_\_

__rmul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `UInt64(4) + 2`.

This will error on overflow

<a id="algopy.TransactionType.__ror__"></a>

### \_\_ror_\_

__ror__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `4 | UInt64(2)`

<a id="algopy.TransactionType.__rpow__"></a>

### \_\_rpow_\_

__rpow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `4 ** UInt64(2)`.

This will error on overflow

<a id="algopy.TransactionType.__rrshift__"></a>

### \_\_rrshift_\_

__rrshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `4 >> UInt64(2)`

<a id="algopy.TransactionType.__rshift__"></a>

### \_\_rshift_\_

__rshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `UInt64(4) >> 2`

<a id="algopy.TransactionType.__rsub__"></a>

### \_\_rsub_\_

__rsub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `4 - UInt64(2)`.

This will error on underflow

<a id="algopy.TransactionType.__rxor__"></a>

### \_\_rxor_\_

__rxor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `4 ^ UInt64(2)`

<a id="algopy.TransactionType.__sub__"></a>

### \_\_sub_\_

__sub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `UInt(4) - 2`.

This will error on underflow

<a id="algopy.TransactionType.__xor__"></a>

### \_\_xor_\_

__xor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `UInt64(4) ^ 2`

<a id="algopy.Txn"></a>

## *class* algopy.Txn

Txn

Get values for the current executing transaction
Native TEAL ops: [`txn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txn), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.accounts"></a>

### *static* accounts

accounts(a: [algopy.UInt64](#algopy.UInt64) | int, /) → [algopy.Account](#algopy.Account)

Accounts listed in the ApplicationCall transaction

Native TEAL opcode: [`txna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txna), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.amount"></a>

### amount

amount *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

microalgos

<a id="algopy.Txn.application_args"></a>

### *static* application_args

application_args(a: [algopy.UInt64](#algopy.UInt64) | int, /) → [algopy.Bytes](#algopy.Bytes)

Arguments passed to the application in the ApplicationCall transaction

Native TEAL opcode: [`txna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txna), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.application_id"></a>

### application_id

application_id *: Final[[algopy.Application](#algopy.Application)]*

Ellipsis

ApplicationID from ApplicationCall transaction

<a id="algopy.Txn.applications"></a>

### *static* applications

applications(a: [algopy.UInt64](#algopy.UInt64) | int, /) → [algopy.Application](#algopy.Application)

Foreign Apps listed in the ApplicationCall transaction

Native TEAL opcode: [`txna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txna), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.approval_program"></a>

### approval_program

approval_program *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

Approval program

<a id="algopy.Txn.approval_program_pages"></a>

### *static* approval_program_pages

approval_program_pages(a: [algopy.UInt64](#algopy.UInt64) | int, /) → [algopy.Bytes](#algopy.Bytes)

Approval Program as an array of pages

Native TEAL opcode: [`txna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txna), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.asset_amount"></a>

### asset_amount

asset_amount *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

value in Asset’s units

<a id="algopy.Txn.asset_close_to"></a>

### asset_close_to

asset_close_to *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.asset_receiver"></a>

### asset_receiver

asset_receiver *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.asset_sender"></a>

### asset_sender

asset_sender *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address. Source of assets if Sender is the Asset’s Clawback address.

<a id="algopy.Txn.assets"></a>

### *static* assets

assets(a: [algopy.UInt64](#algopy.UInt64) | int, /) → [algopy.Asset](#algopy.Asset)

Foreign Assets listed in the ApplicationCall transaction

Native TEAL opcode: [`txna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txna), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.clear_state_program"></a>

### clear_state_program

clear_state_program *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

Clear state program

<a id="algopy.Txn.clear_state_program_pages"></a>

### *static* clear_state_program_pages

clear_state_program_pages(a: [algopy.UInt64](#algopy.UInt64) | int, /) → [algopy.Bytes](#algopy.Bytes)

ClearState Program as an array of pages

Native TEAL opcode: [`txna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txna), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.close_remainder_to"></a>

### close_remainder_to

close_remainder_to *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.config_asset"></a>

### config_asset

config_asset *: Final[[algopy.Asset](#algopy.Asset)]*

Ellipsis

Asset ID in asset config transaction

<a id="algopy.Txn.config_asset_clawback"></a>

### config_asset_clawback

config_asset_clawback *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.config_asset_decimals"></a>

### config_asset_decimals

config_asset_decimals *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of digits to display after the decimal place when displaying the asset

<a id="algopy.Txn.config_asset_default_frozen"></a>

### config_asset_default_frozen

config_asset_default_frozen *: Final[bool]*

Ellipsis

Whether the asset’s slots are frozen by default or not, 0 or 1

<a id="algopy.Txn.config_asset_freeze"></a>

### config_asset_freeze

config_asset_freeze *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.config_asset_manager"></a>

### config_asset_manager

config_asset_manager *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.config_asset_metadata_hash"></a>

### config_asset_metadata_hash

config_asset_metadata_hash *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

32 byte commitment to unspecified asset metadata

<a id="algopy.Txn.config_asset_name"></a>

### config_asset_name

config_asset_name *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

The asset name

<a id="algopy.Txn.config_asset_reserve"></a>

### config_asset_reserve

config_asset_reserve *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.config_asset_total"></a>

### config_asset_total

config_asset_total *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Total number of units of this asset created

<a id="algopy.Txn.config_asset_unit_name"></a>

### config_asset_unit_name

config_asset_unit_name *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

Unit name of the asset

<a id="algopy.Txn.config_asset_url"></a>

### config_asset_url

config_asset_url *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

URL

<a id="algopy.Txn.created_application_id"></a>

### created_application_id

created_application_id *: Final[[algopy.Application](#algopy.Application)]*

Ellipsis

ApplicationID allocated by the creation of an application (only with `itxn` in v5). Application mode only

<a id="algopy.Txn.created_asset_id"></a>

### created_asset_id

created_asset_id *: Final[[algopy.Asset](#algopy.Asset)]*

Ellipsis

Asset ID allocated by the creation of an ASA (only with `itxn` in v5). Application mode only

<a id="algopy.Txn.extra_program_pages"></a>

### extra_program_pages

extra_program_pages *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of additional pages for each of the application’s approval and clear state programs. An ExtraProgramPages of 1 means 2048 more total bytes, or 1024 for each program.

<a id="algopy.Txn.fee"></a>

### fee

fee *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

microalgos

<a id="algopy.Txn.first_valid"></a>

### first_valid

first_valid *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

round number

<a id="algopy.Txn.first_valid_time"></a>

### first_valid_time

first_valid_time *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

UNIX timestamp of block before txn.FirstValid. Fails if negative

<a id="algopy.Txn.freeze_asset"></a>

### freeze_asset

freeze_asset *: Final[[algopy.Asset](#algopy.Asset)]*

Ellipsis

Asset ID being frozen or un-frozen

<a id="algopy.Txn.freeze_asset_account"></a>

### freeze_asset_account

freeze_asset_account *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address of the account whose asset slot is being frozen or un-frozen

<a id="algopy.Txn.freeze_asset_frozen"></a>

### freeze_asset_frozen

freeze_asset_frozen *: Final[bool]*

Ellipsis

The new frozen value, 0 or 1

<a id="algopy.Txn.global_num_byte_slice"></a>

### global_num_byte_slice

global_num_byte_slice *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of global state byteslices in ApplicationCall

<a id="algopy.Txn.global_num_uint"></a>

### global_num_uint

global_num_uint *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of global state integers in ApplicationCall

<a id="algopy.Txn.group_index"></a>

### group_index

group_index *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Position of this transaction within an atomic transaction group. A stand-alone transaction is implicitly element 0 in a group of 1

<a id="algopy.Txn.last_log"></a>

### last_log

last_log *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

The last message emitted. Empty bytes if none were emitted. Application mode only

<a id="algopy.Txn.last_valid"></a>

### last_valid

last_valid *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

round number

<a id="algopy.Txn.lease"></a>

### lease

lease *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

32 byte lease value

<a id="algopy.Txn.local_num_byte_slice"></a>

### local_num_byte_slice

local_num_byte_slice *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of local state byteslices in ApplicationCall

<a id="algopy.Txn.local_num_uint"></a>

### local_num_uint

local_num_uint *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of local state integers in ApplicationCall

<a id="algopy.Txn.logs"></a>

### *static* logs

logs(a: [algopy.UInt64](#algopy.UInt64) | int, /) → [algopy.Bytes](#algopy.Bytes)

Log messages emitted by an application call (only with `itxn` in v5). Application mode only

Native TEAL opcode: [`txna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txna), [`txnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#txnas)

<a id="algopy.Txn.nonparticipation"></a>

### nonparticipation

nonparticipation *: Final[bool]*

Ellipsis

Marks an account nonparticipating for rewards

<a id="algopy.Txn.note"></a>

### note

note *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

Any data up to 1024 bytes

<a id="algopy.Txn.num_accounts"></a>

### num_accounts

num_accounts *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of Accounts

<a id="algopy.Txn.num_app_args"></a>

### num_app_args

num_app_args *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of ApplicationArgs

<a id="algopy.Txn.num_applications"></a>

### num_applications

num_applications *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of Applications

<a id="algopy.Txn.num_approval_program_pages"></a>

### num_approval_program_pages

num_approval_program_pages *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of Approval Program pages

<a id="algopy.Txn.num_assets"></a>

### num_assets

num_assets *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of Assets

<a id="algopy.Txn.num_clear_state_program_pages"></a>

### num_clear_state_program_pages

num_clear_state_program_pages *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of ClearState Program pages

<a id="algopy.Txn.num_logs"></a>

### num_logs

num_logs *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Number of Logs (only with `itxn` in v5). Application mode only

<a id="algopy.Txn.on_completion"></a>

### on_completion

on_completion *: Final[[algopy.OnCompleteAction](#algopy.OnCompleteAction)]*

Ellipsis

ApplicationCall transaction on completion action

<a id="algopy.Txn.receiver"></a>

### receiver

receiver *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.rekey_to"></a>

### rekey_to

rekey_to *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte Sender’s new AuthAddr

<a id="algopy.Txn.selection_pk"></a>

### selection_pk

selection_pk *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

32 byte address

<a id="algopy.Txn.sender"></a>

### sender

sender *: Final[[algopy.Account](#algopy.Account)]*

Ellipsis

32 byte address

<a id="algopy.Txn.state_proof_pk"></a>

### state_proof_pk

state_proof_pk *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

64 byte state proof public key

<a id="algopy.Txn.tx_id"></a>

### tx_id

tx_id *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

The computed ID for this transaction. 32 bytes.

<a id="algopy.Txn.type"></a>

### type

type *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

Transaction type as bytes

<a id="algopy.Txn.type_enum"></a>

### type_enum

type_enum *: Final[[algopy.TransactionType](#algopy.TransactionType)]*

Ellipsis

Transaction type as integer

<a id="algopy.Txn.vote_first"></a>

### vote_first

vote_first *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The first round that the participation key is valid.

<a id="algopy.Txn.vote_key_dilution"></a>

### vote_key_dilution

vote_key_dilution *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

Dilution for the 2-level participation key

<a id="algopy.Txn.vote_last"></a>

### vote_last

vote_last *: Final[[algopy.UInt64](#algopy.UInt64)]*

Ellipsis

The last round that the participation key is valid.

<a id="algopy.Txn.vote_pk"></a>

### vote_pk

vote_pk *: Final[[algopy.Bytes](#algopy.Bytes)]*

Ellipsis

32 byte address

<a id="algopy.Txn.xfer_asset"></a>

### xfer_asset

xfer_asset *: Final[[algopy.Asset](#algopy.Asset)]*

Ellipsis

Asset ID

<a id="algopy.UInt64"></a>

## *class* algopy.UInt64

UInt64(value: int = 0, /)

A 64-bit unsigned integer, one of the primary data types on the AVM

## Initialization

A UInt64 can be initialized with a Python int literal, or an int variable
declared at the module level

<a id="algopy.UInt64.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `UInt(4) + 2`.

This will error on overflow

<a id="algopy.UInt64.__and__"></a>

### \_\_and_\_

__and__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `UInt64(4) & 2`

<a id="algopy.UInt64.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

A UInt64 will evaluate to `False` if zero, and `True` otherwise

<a id="algopy.UInt64.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `==` operator with another UInt64 or int

<a id="algopy.UInt64.__floordiv__"></a>

### \_\_floordiv_\_

__floordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `UInt64(4) // 2`.

This will error on divide by zero

<a id="algopy.UInt64.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>=` operator with another UInt64 or int

<a id="algopy.UInt64.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `>` operator with another UInt64 or int

<a id="algopy.UInt64.__iadd__"></a>

### \_\_iadd_\_

__iadd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be incremented with another UInt64 or int e.g. `a += UInt(2)`.

This will error on overflow

<a id="algopy.UInt64.__iand__"></a>

### \_\_iand_\_

__iand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `a &= UInt64(2)`

<a id="algopy.UInt64.__ifloordiv__"></a>

### \_\_ifloordiv_\_

__ifloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `a //= UInt64(2)`.

This will error on divide by zero

<a id="algopy.UInt64.__ilshift__"></a>

### \_\_ilshift_\_

__ilshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `a <<= UInt64(2)`

<a id="algopy.UInt64.__imod__"></a>

### \_\_imod_\_

__imod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `a %= UInt64(2)`.

This will error on mod by zero

<a id="algopy.UInt64.__imul__"></a>

### \_\_imul_\_

__imul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `a*= UInt64(2)`.

This will error on overflow

<a id="algopy.UInt64.__index__"></a>

### \_\_index_\_

__index__() → int

A UInt64 can be used in indexing/slice expressions

<a id="algopy.UInt64.__invert__"></a>

### \_\_invert_\_

__invert__() → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be bitwise inverted e.g. `~UInt64(4)`

<a id="algopy.UInt64.__ior__"></a>

### \_\_ior_\_

__ior__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `a |= UInt64(2)`

<a id="algopy.UInt64.__ipow__"></a>

### \_\_ipow_\_

__ipow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `a **= UInt64(2)`.

This will error on overflow

<a id="algopy.UInt64.__irshift__"></a>

### \_\_irshift_\_

__irshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `a >>= UInt64(2)`

<a id="algopy.UInt64.__isub__"></a>

### \_\_isub_\_

__isub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `a -= UInt64(2)`.

This will error on underflow

<a id="algopy.UInt64.__ixor__"></a>

### \_\_ixor_\_

__ixor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `a ^= UInt64(2)`

<a id="algopy.UInt64.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<=` operator with another UInt64 or int

<a id="algopy.UInt64.__lshift__"></a>

### \_\_lshift_\_

__lshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `UInt64(4) << 2`

<a id="algopy.UInt64.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `<` operator with another UInt64 or int

<a id="algopy.UInt64.__mod__"></a>

### \_\_mod_\_

__mod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `UInt64(4) % 2`.

This will error on mod by zero

<a id="algopy.UInt64.__mul__"></a>

### \_\_mul_\_

__mul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.UInt64.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.UInt64](#algopy.UInt64) | int) → bool

A UInt64 can use the `!=` operator with another UInt64 or int

<a id="algopy.UInt64.__or__"></a>

### \_\_or_\_

__or__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `UInt64(4) | 2`

<a id="algopy.UInt64.__pos__"></a>

### \_\_pos_\_

__pos__() → [algopy.UInt64](#algopy.UInt64)

Supports unary + operator. Redundant given the type is unsigned

<a id="algopy.UInt64.__pow__"></a>

### \_\_pow_\_

__pow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `UInt64(4) ** 2`.

This will error on overflow

<a id="algopy.UInt64.__radd__"></a>

### \_\_radd_\_

__radd__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be added with another UInt64 or int e.g. `4 + UInt64(2)`.

This will error on overflow

<a id="algopy.UInt64.__rand__"></a>

### \_\_rand_\_

__rand__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise and with another UInt64 or int e.g. `4 & UInt64(2)`

<a id="algopy.UInt64.__rfloordiv__"></a>

### \_\_rfloordiv_\_

__rfloordiv__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be floor divided with another UInt64 or int e.g. `4 // UInt64(2)`.

This will error on divide by zero

<a id="algopy.UInt64.__rlshift__"></a>

### \_\_rlshift_\_

__rlshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be left shifted by another UInt64 or int e.g. `4 << UInt64(2)`

<a id="algopy.UInt64.__rmod__"></a>

### \_\_rmod_\_

__rmod__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be modded with another UInt64 or int e.g. `4 % UInt64(2)`.

This will error on mod by zero

<a id="algopy.UInt64.__rmul__"></a>

### \_\_rmul_\_

__rmul__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be multiplied with another UInt64 or int e.g. `UInt64(4) + 2`.

This will error on overflow

<a id="algopy.UInt64.__ror__"></a>

### \_\_ror_\_

__ror__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise or with another UInt64 or int e.g. `4 | UInt64(2)`

<a id="algopy.UInt64.__rpow__"></a>

### \_\_rpow_\_

__rpow__(power: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be raised to the power of another UInt64 or int e.g. `4 ** UInt64(2)`.

This will error on overflow

<a id="algopy.UInt64.__rrshift__"></a>

### \_\_rrshift_\_

__rrshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `4 >> UInt64(2)`

<a id="algopy.UInt64.__rshift__"></a>

### \_\_rshift_\_

__rshift__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be right shifted by another UInt64 or int e.g. `UInt64(4) >> 2`

<a id="algopy.UInt64.__rsub__"></a>

### \_\_rsub_\_

__rsub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `4 - UInt64(2)`.

This will error on underflow

<a id="algopy.UInt64.__rxor__"></a>

### \_\_rxor_\_

__rxor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `4 ^ UInt64(2)`

<a id="algopy.UInt64.__sub__"></a>

### \_\_sub_\_

__sub__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can be subtracted with another UInt64 or int e.g. `UInt(4) - 2`.

This will error on underflow

<a id="algopy.UInt64.__xor__"></a>

### \_\_xor_\_

__xor__(other: [algopy.UInt64](#algopy.UInt64) | int) → [algopy.UInt64](#algopy.UInt64)

A UInt64 can bitwise xor with another UInt64 or int e.g. `UInt64(4) ^ 2`

<a id="algopy.compile_contract"></a>

## algopy.compile_contract

compile_contract(contract: type[[Contract](#algopy.Contract)], /, \*, extra_program_pages: [algopy.UInt64](#algopy.UInt64) | int = ..., global_uints: [algopy.UInt64](#algopy.UInt64) | int = ..., global_bytes: [algopy.UInt64](#algopy.UInt64) | int = ..., local_uints: [algopy.UInt64](#algopy.UInt64) | int = ..., local_bytes: [algopy.UInt64](#algopy.UInt64) | int = ..., template_vars: collections.abc.Mapping[str, object] = ..., template_vars_prefix: str = ...) → [algopy.CompiledContract](#algopy.CompiledContract)

Returns the compiled data for the specified contract

:param contract: Algorand Python Contract to compile
:param extra_program_pages: Number of extra program pages, defaults to minimum required for contract
:param global_uints: Number of global uint64s, defaults to value defined for contract
:param global_bytes: Number of global bytes, defaults to value defined for contract
:param local_uints: Number of local uint64s, defaults to value defined for contract
:param local_bytes: Number of local bytes, defaults to value defined for contract
:param template_vars: Template variables to substitute into the contract,
key should be without the prefix, must evaluate to a compile time constant
and match the type of the template var declaration
:param template_vars_prefix: Prefix to add to provided template vars,
defaults to the prefix supplied on command line (which defaults to TMPL_)

<a id="algopy.compile_logicsig"></a>

## algopy.compile_logicsig

compile_logicsig(logicsig: [LogicSig](#algopy.LogicSig), /, \*, template_vars: collections.abc.Mapping[str, object] = ..., template_vars_prefix: str = ...) → [algopy.CompiledLogicSig](#algopy.CompiledLogicSig)

Returns the Account for the specified logic signature

:param logicsig: Algorand Python Logic Signature to compile
:param template_vars: Template variables to substitute into the logic signature,
key should be without the prefix, must evaluate to a compile time constant
and match the type of the template var declaration
:param template_vars_prefix: Prefix to add to provided template vars,
defaults to the prefix supplied on command line (which defaults to TMPL_)

<a id="algopy.ensure_budget"></a>

## algopy.ensure_budget

ensure_budget(required_budget: [algopy.UInt64](#algopy.UInt64) | int, fee_source: [algopy.OpUpFeeSource](#algopy.OpUpFeeSource) = ...) → None

Ensure the available op code budget is greater than or equal to required_budget

<a id="algopy.log"></a>

## algopy.log

log(\*args: [algopy.UInt64](#algopy.UInt64) | [algopy.Bytes](#algopy.Bytes) | [algopy.BytesBacked](#algopy.BytesBacked) | str | bytes | int, sep: [algopy.String](#algopy.String) | str | [algopy.Bytes](#algopy.Bytes) | bytes = '') → None

Concatenates and logs supplied args as a single bytes value.

UInt64 args are converted to bytes and each argument is separated by `sep`.
Literal `str` values will be encoded as UTF8.

<a id="algopy.logicsig"></a>

## algopy.logicsig

logicsig(\*, name: str = ..., avm_version: int = ...) → collections.abc.Callable[[collections.abc.Callable[[], bool | [algopy.UInt64](#algopy.UInt64)]], [algopy.LogicSig](#algopy.LogicSig)]

Decorator to indicate a function is a logic signature

<a id="algopy.subroutine"></a>

## algopy.subroutine

subroutine(sub: collections.abc.Callable[algopy._P, algopy._R], /) → collections.abc.Callable[algopy._P, algopy._R]

Decorator to indicate functions or methods that can be called by a Smart Contract

<a id="algopy.uenumerate"></a>

## *class* algopy.uenumerate

uenumerate(iterable: collections.abc.Iterable[algopy._T])

Yields pairs containing a count (from zero) and a value yielded by the iterable argument.

enumerate is useful for obtaining an indexed list:
(0, seq[0]), (1, seq[1]), (2, seq[2]), …

enumerate((a, b, c)) produces (0, a), (1, b), (2, c)

## Initialization

<a id="algopy.urange"></a>

## *class* algopy.urange

urange

Produces a sequence of UInt64 from start (inclusive) to stop (exclusive) by step.

urange(4) produces 0, 1, 2, 3
urange(i, j) produces i, i+1, i+2, …, j-1.
urange(i, j, 2) produces i, i+2, i+4, …, i+2n where n is the largest value where i+2n \< j
