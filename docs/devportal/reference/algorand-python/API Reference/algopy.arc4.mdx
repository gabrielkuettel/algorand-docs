---
title: "algopy.arc4"
---

<a id="module-algopy.arc4"></a>

<a id="algopy-arc4"></a>

<a id="module-contents"></a>

<a id="classes"></a>

## Classes

| [`ARC4Client`](#algopy.arc4.ARC4Client)     | Used to provide typed method signatures for ARC4 contracts                                                                                                                                                                     |
|---------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`ARC4Contract`](#algopy.arc4.ARC4Contract) | The base class for a contract that conforms to the [ARC4 ABI specification](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md). Most contracts<br/>should inherit from this class or a superclass thereof. |
| [`Address`](#algopy.arc4.Address)           | An alias for an array containing 32 bytes representing an Algorand address                                                                                                                                                     |
| [`BigUFixedNxM`](#algopy.arc4.BigUFixedNxM) | An ARC4 UFixed representing a decimal with the number of bits and precision specified.                                                                                                                                         |
| [`BigUIntN`](#algopy.arc4.BigUIntN)         | An ARC4 UInt consisting of the number of bits specified.                                                                                                                                                                       |
| [`Bool`](#algopy.arc4.Bool)                 | An ARC4 encoded bool. The most significant bit is `1` for `True` and `0` for `False`                                                                                                                                           |
| [`Byte`](#algopy.arc4.Byte)                 | An ARC4 alias for a UInt8                                                                                                                                                                                                      |
| [`DynamicArray`](#algopy.arc4.DynamicArray) | A dynamically sized ARC4 Array of the specified type                                                                                                                                                                           |
| [`DynamicBytes`](#algopy.arc4.DynamicBytes) | A variable sized array of bytes                                                                                                                                                                                                |
| [`StaticArray`](#algopy.arc4.StaticArray)   | A fixed length ARC4 Array of the specified type and length                                                                                                                                                                     |
| [`String`](#algopy.arc4.String)             | An ARC4 sequence of bytes containing a UTF8 string.                                                                                                                                                                            |
| [`Struct`](#algopy.arc4.Struct)             | Base class for ARC4 Struct types. ARC4 Structs are named tuples. The class keyword `frozen`<br/>can be used to indicate if a struct can be mutated.                                                                            |
| [`Tuple`](#algopy.arc4.Tuple)               | An ARC4 ABI tuple, containing other ARC4 ABI types. ARC4 Tuples are immutable statically<br/>sized arrays of mixed item types. Item types can be specified via generic parameters or<br/>inferred from constructor parameters. |
| [`UFixedNxM`](#algopy.arc4.UFixedNxM)       | An ARC4 UFixed representing a decimal with the number of bits and precision specified.                                                                                                                                         |
| [`UIntN`](#algopy.arc4.UIntN)               | An ARC4 UInt consisting of the number of bits specified (big-endian encoded).                                                                                                                                                  |

<a id="functions"></a>

## Functions

| [`abimethod`](#algopy.arc4.abimethod)           | Decorator that indicates a method is an ARC4 ABI method. If the method should not be externally<br/>callable, use [`algopy.subroutine()`](algopy.mdx#algopy.subroutine) instead.   |
|-------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`arc4_create`](#algopy.arc4.arc4_create)       | Provides a typesafe and convenient way of creating an ARC4Contract via an inner transaction                                                                                        |
| [`arc4_signature`](#algopy.arc4.arc4_signature) | Returns the ARC4 encoded method selector for the specified signature                                                                                                               |
| [`arc4_update`](#algopy.arc4.arc4_update)       | Provides a typesafe and convenient way of updating an ARC4Contract via an inner transaction                                                                                        |
| [`baremethod`](#algopy.arc4.baremethod)         | Decorator that indicates a method is an ARC4 bare method.                                                                                                                          |
| [`emit`](#algopy.arc4.emit)                     | Emit an ARC-28 event for the provided event signature or name, and provided args.                                                                                                  |

<a id="data"></a>

## Data

| [`UInt128`](#algopy.arc4.UInt128)   | An ARC4 UInt128                                                          |
|-------------------------------------|--------------------------------------------------------------------------|
| [`UInt16`](#algopy.arc4.UInt16)     | An ARC4 UInt16                                                           |
| [`UInt256`](#algopy.arc4.UInt256)   | An ARC4 UInt256                                                          |
| [`UInt32`](#algopy.arc4.UInt32)     | An ARC4 UInt32                                                           |
| [`UInt512`](#algopy.arc4.UInt512)   | An ARC4 UInt512                                                          |
| [`UInt64`](#algopy.arc4.UInt64)     | An ARC4 UInt64                                                           |
| [`UInt8`](#algopy.arc4.UInt8)       | An ARC4 UInt8                                                            |
| [`abi_call`](#algopy.arc4.abi_call) | Provides a typesafe way of calling ARC4 methods via an inner transaction |

<a id="api"></a>

## API

<a id="algopy.arc4.ARC4Client"></a>

## *class* algopy.arc4.ARC4Client

ARC4Client

Used to provide typed method signatures for ARC4 contracts

<a id="algopy.arc4.ARC4Contract"></a>

## *class* algopy.arc4.ARC4Contract

ARC4Contract

The base class for a contract that conforms to the [ARC4 ABI specification](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md). Most contracts
should inherit from this class or a superclass thereof.

```python
class HelloWorldContract(ARC4Contract):
    # ...
```

Functions decorated with [`algopy.arc4.abimethod()`](#algopy.arc4.abimethod) or [`algopy.arc4.baremethod()`](#algopy.arc4.baremethod) will form the public
interface of the contract.

The [`algopy.arc4.ARC4Contract.approval_program()`](#algopy.arc4.ARC4Contract.approval_program) will be implemented by the compiler, and route application args
according to the ARC4 ABI specification.

The [`algopy.arc4.ARC4Contract.clear_state_program()`](#algopy.arc4.ARC4Contract.clear_state_program) will by default return True, but can be overridden

The Puya compiler will generate ARC32 and ARC56 application specifications for the contract
automatically.

<a id="algopy.arc4.ARC4Contract.__init_subclass__"></a>

### *classmethod* \_\_init_subclass_\_

__init_subclass__(\*, name: str = ..., scratch_slots: [algopy.urange](algopy.mdx#algopy.urange) | tuple[int | [algopy.urange](algopy.mdx#algopy.urange), ...] | list[int | [algopy.urange](algopy.mdx#algopy.urange)] = ..., state_totals: [algopy.StateTotals](algopy.mdx#algopy.StateTotals) = ..., avm_version: int = ...)

When declaring a Contract subclass, options and configuration are passed in
the base class list:

```python
class MyContract(algopy.Contract, name="CustomName"):
    ...
```

:param name:
Will affect the output TEAL file name if there are multiple non-abstract contracts
in the same file.

If the contract is a subclass of algopy.ARC4Contract, `name` will also be used as the
contract name in the ARC-32 application.json, instead of the class name.

:param scratch_slots:
Allows you to mark a slot ID or range of slot IDs as “off limits” to Puya.
These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.
This is particularly useful in combination with `algopy.op.gload_bytes` / `algopy.op.gload_uint64`
which lets a contract in a group transaction read from the scratch slots of another contract
that occurs earlier in the transaction group.

In the case of inheritance, scratch slots reserved become cumulative. It is not an error
to have overlapping ranges or values either, so if a base class contract reserves slots
0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived
contract all slots 0-10 will be marked as reserved.

:param state_totals:
Allows defining what values should be used for global and local uint and bytes storage
values when creating a contract. Used when outputting ARC-32 application.json schemas.

If let unspecified, the totals will be determined by the compiler based on state
variables assigned to `self`.

This setting is not inherited, and only applies to the exact `Contract` it is specified
on. If a base class does specify this setting, and a derived class does not, a warning
will be emitted for the derived class. To resolve this warning, `state_totals` must be
specified. Note that it is valid to not provide any arguments to the `StateTotals`
constructor, like so `state_totals=StateTotals()`, in which case all values will be
automatically calculated.
:param avm_version:
Determines which AVM version to use, this affects what operations are supported.
Defaults to value provided supplied on command line (which defaults to current mainnet version)

<a id="algopy.arc4.ARC4Contract.approval_program"></a>

### approval_program

approval_program() → bool

The approval program for the ARC4Contract is implemented by the compile in
accordance with ARC4

<a id="algopy.arc4.ARC4Contract.clear_state_program"></a>

### clear_state_program

clear_state_program() → [algopy.UInt64](algopy.mdx#algopy.UInt64) | bool

The clear_state_program contains the logic when the `OnCompletion` is `ClearState`.

The default implementation simply returns True, but this can be overridden.

ClearState transactions always clear local state of the sender. Documentation on
`ClearState` behavior should be read before implementing this method: https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/apps/#clear-state

<a id="algopy.arc4.Address"></a>

## *class* algopy.arc4.Address

Address(value: [algopy.Account](algopy.mdx#algopy.Account) | str | [algopy.Bytes](algopy.mdx#algopy.Bytes) = ..., /)

An alias for an array containing 32 bytes representing an Algorand address

## Initialization

If `value` is a string, it should be a 58 character base32 string,
ie a base32 string-encoded 32 bytes public key + 4 bytes checksum.
If `value` is a Bytes, it’s length checked to be 32 bytes - to avoid this
check, use `Address.from_bytes(...)` instead.
Defaults to the zero-address.

<a id="algopy.arc4.Address.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not equal to the zero address

<a id="algopy.arc4.Address.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.arc4.Address](#algopy.arc4.Address) | [algopy.Account](algopy.mdx#algopy.Account) | str) → bool

Address equality is determined by the address of another
`arc4.Address`, `Account` or `str`

<a id="algopy.arc4.Address.__getitem__"></a>

### \_\_getitem_\_

__getitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.Address.__iter__"></a>

### \_\_iter_\_

__iter__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.Address.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.arc4.Address](#algopy.arc4.Address) | [algopy.Account](algopy.mdx#algopy.Account) | str) → bool

Address equality is determined by the address of another
`arc4.Address`, `Account` or `str`

<a id="algopy.arc4.Address.__reversed__"></a>

### \_\_reversed_\_

__reversed__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.Address.__setitem__"></a>

### \_\_setitem_\_

__setitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.Address.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Address.copy"></a>

### copy

copy() → Self

Create a copy of this array

<a id="algopy.arc4.Address.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Address.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Address.length"></a>

### *property* length

length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.Address.native"></a>

### *property* native

native *: [algopy.Account](algopy.mdx#algopy.Account)*

Return the Account representation of the address after ARC4 decoding

<a id="algopy.arc4.BigUFixedNxM"></a>

## *class* algopy.arc4.BigUFixedNxM

BigUFixedNxM(value: str = '0.0', /)

An ARC4 UFixed representing a decimal with the number of bits and precision specified.

Max size: 512 bits

## Initialization

Construct an instance of UFixedNxM where value (v) is determined from the original
decimal value (d) by the formula v = round(d \* (10^M))

<a id="algopy.arc4.BigUFixedNxM.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.BigUFixedNxM.__eq__"></a>

### \_\_eq_\_

__eq__(other: Self) → bool

Compare for equality, note both operands must be the exact same type

<a id="algopy.arc4.BigUFixedNxM.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.BigUFixedNxM.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.BigUFixedNxM.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.BigUIntN"></a>

## *class* algopy.arc4.BigUIntN

BigUIntN(value: [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, /)

An ARC4 UInt consisting of the number of bits specified.

Max size: 512 bits

## Initialization

<a id="algopy.arc4.BigUIntN.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.BigUIntN.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self==value.

<a id="algopy.arc4.BigUIntN.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>=value.

<a id="algopy.arc4.BigUIntN.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>value.

<a id="algopy.arc4.BigUIntN.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<=value.

<a id="algopy.arc4.BigUIntN.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<value.

<a id="algopy.arc4.BigUIntN.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self!=value.

<a id="algopy.arc4.BigUIntN.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.BigUIntN.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.BigUIntN.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.BigUIntN.native"></a>

### *property* native

native *: [algopy.BigUInt](algopy.mdx#algopy.BigUInt)*

Return the BigUInt representation of the value after ARC4 decoding

<a id="algopy.arc4.Bool"></a>

## *class* algopy.arc4.Bool

Bool(value: bool = False, /)

An ARC4 encoded bool. The most significant bit is `1` for `True` and `0` for `False`

## Initialization

<a id="algopy.arc4.Bool.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.arc4.Bool](#algopy.arc4.Bool) | bool) → bool

Return self==value.

<a id="algopy.arc4.Bool.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.arc4.Bool](#algopy.arc4.Bool) | bool) → bool

Return self!=value.

<a id="algopy.arc4.Bool.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Bool.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Bool.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Bool.native"></a>

### *property* native

native *: bool*

Return the bool representation of the value after ARC4 decoding

<a id="algopy.arc4.Byte"></a>

## *class* algopy.arc4.Byte

Byte(value: [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, /)

An ARC4 alias for a UInt8

## Initialization

<a id="algopy.arc4.Byte.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.Byte.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self==value.

<a id="algopy.arc4.Byte.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>=value.

<a id="algopy.arc4.Byte.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>value.

<a id="algopy.arc4.Byte.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<=value.

<a id="algopy.arc4.Byte.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<value.

<a id="algopy.arc4.Byte.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self!=value.

<a id="algopy.arc4.Byte.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Byte.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Byte.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Byte.native"></a>

### *property* native

native *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Return the UInt64 representation of the value after ARC4 decoding

<a id="algopy.arc4.DynamicArray"></a>

## *class* algopy.arc4.DynamicArray

DynamicArray(\*items: algopy.arc4._TArrayItem)

A dynamically sized ARC4 Array of the specified type

```python
import typing as t
from algopy import arc4

UInt64Array: t.TypeAlias = arc4.DynamicArray[arc4.UInt64]
```

## Initialization

Initializes a new array with items provided

<a id="algopy.arc4.DynamicArray.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...]) → [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem]

Concat two arrays together, returning a new array

<a id="algopy.arc4.DynamicArray.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not an empty array

<a id="algopy.arc4.DynamicArray.__getitem__"></a>

### \_\_getitem_\_

__getitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.DynamicArray.__iter__"></a>

### \_\_iter_\_

__iter__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.DynamicArray.__reversed__"></a>

### \_\_reversed_\_

__reversed__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.DynamicArray.__setitem__"></a>

### \_\_setitem_\_

__setitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.DynamicArray.append"></a>

### append

append(item: algopy.arc4._TArrayItem, /) → None

Append an item to this array

<a id="algopy.arc4.DynamicArray.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.DynamicArray.copy"></a>

### copy

copy() → Self

Create a copy of this array

<a id="algopy.arc4.DynamicArray.extend"></a>

### extend

extend(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...], /) → None

Extend this array with the contents of another array

<a id="algopy.arc4.DynamicArray.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.DynamicArray.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.DynamicArray.length"></a>

### *property* length

length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.DynamicArray.pop"></a>

### pop

pop() → algopy.arc4._TArrayItem

Remove and return the last item of this array

<a id="algopy.arc4.DynamicBytes"></a>

## *class* algopy.arc4.DynamicBytes

DynamicBytes

A variable sized array of bytes

<a id="algopy.arc4.DynamicBytes.__add__"></a>

### \_\_add_\_

__add__(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...]) → [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem]

Concat two arrays together, returning a new array

<a id="algopy.arc4.DynamicBytes.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not an empty array

<a id="algopy.arc4.DynamicBytes.__getitem__"></a>

### \_\_getitem_\_

__getitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.DynamicBytes.__iter__"></a>

### \_\_iter_\_

__iter__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.DynamicBytes.__reversed__"></a>

### \_\_reversed_\_

__reversed__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.DynamicBytes.__setitem__"></a>

### \_\_setitem_\_

__setitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.DynamicBytes.append"></a>

### append

append(item: algopy.arc4._TArrayItem, /) → None

Append an item to this array

<a id="algopy.arc4.DynamicBytes.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.DynamicBytes.copy"></a>

### copy

copy() → Self

Create a copy of this array

<a id="algopy.arc4.DynamicBytes.extend"></a>

### extend

extend(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...], /) → None

Extend this array with the contents of another array

<a id="algopy.arc4.DynamicBytes.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.DynamicBytes.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.DynamicBytes.length"></a>

### *property* length

length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.DynamicBytes.native"></a>

### *property* native

native *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Return the Bytes representation of the address after ARC4 decoding

<a id="algopy.arc4.DynamicBytes.pop"></a>

### pop

pop() → algopy.arc4._TArrayItem

Remove and return the last item of this array

<a id="algopy.arc4.StaticArray"></a>

## *class* algopy.arc4.StaticArray

StaticArray

A fixed length ARC4 Array of the specified type and length

```python
import typing as t
from algopy import arc4

FourBytes: t.TypeAlias = arc4.StaticArray[arc4.Byte, t.Literal[4]]
```

<a id="algopy.arc4.StaticArray.__getitem__"></a>

### \_\_getitem_\_

__getitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.StaticArray.__iter__"></a>

### \_\_iter_\_

__iter__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.StaticArray.__reversed__"></a>

### \_\_reversed_\_

__reversed__() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.StaticArray.__setitem__"></a>

### \_\_setitem_\_

__setitem__(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.StaticArray.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.StaticArray.copy"></a>

### copy

copy() → Self

Create a copy of this array

<a id="algopy.arc4.StaticArray.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.StaticArray.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.StaticArray.length"></a>

### *property* length

length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.String"></a>

## *class* algopy.arc4.String

String(value: [algopy.String](algopy.mdx#algopy.String) | str = '', /)

An ARC4 sequence of bytes containing a UTF8 string.

The length is the number of bytes, NOT the number of characters

## Initialization

<a id="algopy.arc4.String.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if length is not zero

<a id="algopy.arc4.String.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.arc4.String](#algopy.arc4.String) | [algopy.String](algopy.mdx#algopy.String) | str) → bool

Return self==value.

<a id="algopy.arc4.String.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.String.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.String.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.String.native"></a>

### *property* native

native *: [algopy.String](algopy.mdx#algopy.String)*

Return the String representation of the UTF8 string after ARC4 decoding

<a id="algopy.arc4.Struct"></a>

## *class* algopy.arc4.Struct

Struct

Base class for ARC4 Struct types. ARC4 Structs are named tuples. The class keyword `frozen`
can be used to indicate if a struct can be mutated.

Items can be accessed and mutated via names instead of indexes. Structs do not have a `.native`
property, but a NamedTuple can be used in ABI methods are will be encoded/decode to an ARC4
struct automatically.

```python
import typing

from algopy import arc4

Decimal: typing.TypeAlias = arc4.UFixedNxM[typing.Literal[64], typing.Literal[9]]

class Vector(arc4.Struct, kw_only=True, frozen=True):
    x: Decimal
    y: Decimal
```

<a id="algopy.arc4.Struct.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying bytes[]

<a id="algopy.arc4.Struct.copy"></a>

### copy

copy() → Self

Create a copy of this struct

<a id="algopy.arc4.Struct.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes[] (no validation)

<a id="algopy.arc4.Struct.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Tuple"></a>

## *class* algopy.arc4.Tuple

Tuple(items: tuple[Unpack[algopy.arc4._TTuple]], /)

An ARC4 ABI tuple, containing other ARC4 ABI types. ARC4 Tuples are immutable statically
sized arrays of mixed item types. Item types can be specified via generic parameters or
inferred from constructor parameters.

## Initialization

Construct an ARC4 tuple from a native Python tuple

<a id="algopy.arc4.Tuple.__add__"></a>

### \_\_add_\_

__add__()

Return self+value.

<a id="algopy.arc4.Tuple.__contains__"></a>

### \_\_contains_\_

__contains__()

Return bool(key in self).

<a id="algopy.arc4.Tuple.__delattr__"></a>

### \_\_delattr_\_

__delattr__()

Implement delattr(self, name).

<a id="algopy.arc4.Tuple.__dir__"></a>

### \_\_dir_\_

__dir__()

Default dir() implementation.

<a id="algopy.arc4.Tuple.__eq__"></a>

### \_\_eq_\_

__eq__()

Return self==value.

<a id="algopy.arc4.Tuple.__format__"></a>

### \_\_format_\_

__format__()

Default object formatter.

Return str(self) if format_spec is empty. Raise TypeError otherwise.

<a id="algopy.arc4.Tuple.__ge__"></a>

### \_\_ge_\_

__ge__()

Return self\>=value.

<a id="algopy.arc4.Tuple.__getattribute__"></a>

### \_\_getattribute_\_

__getattribute__()

Return getattr(self, name).

<a id="algopy.arc4.Tuple.__getitem__"></a>

### \_\_getitem_\_

__getitem__()

Return self[key].

<a id="algopy.arc4.Tuple.__getstate__"></a>

### \_\_getstate_\_

__getstate__()

Helper for pickle.

<a id="algopy.arc4.Tuple.__gt__"></a>

### \_\_gt_\_

__gt__()

Return self\>value.

<a id="algopy.arc4.Tuple.__hash__"></a>

### \_\_hash_\_

__hash__()

Return hash(self).

<a id="algopy.arc4.Tuple.__iter__"></a>

### \_\_iter_\_

__iter__()

Implement iter(self).

<a id="algopy.arc4.Tuple.__le__"></a>

### \_\_le_\_

__le__()

Return self\<=value.

<a id="algopy.arc4.Tuple.__len__"></a>

### \_\_len_\_

__len__()

Return len(self).

<a id="algopy.arc4.Tuple.__lt__"></a>

### \_\_lt_\_

__lt__()

Return self\<value.

<a id="algopy.arc4.Tuple.__mul__"></a>

### \_\_mul_\_

__mul__()

Return self\*value.

<a id="algopy.arc4.Tuple.__ne__"></a>

### \_\_ne_\_

__ne__()

Return self!=value.

<a id="algopy.arc4.Tuple.__new__"></a>

### \_\_new_\_

__new__()

Create and return a new object.  See help(type) for accurate signature.

<a id="algopy.arc4.Tuple.__reduce__"></a>

### \_\_reduce_\_

__reduce__()

Helper for pickle.

<a id="algopy.arc4.Tuple.__reduce_ex__"></a>

### \_\_reduce_ex_\_

__reduce_ex__()

Helper for pickle.

<a id="algopy.arc4.Tuple.__repr__"></a>

### \_\_repr_\_

__repr__()

Return repr(self).

<a id="algopy.arc4.Tuple.__rmul__"></a>

### \_\_rmul_\_

__rmul__()

Return value\*self.

<a id="algopy.arc4.Tuple.__setattr__"></a>

### \_\_setattr_\_

__setattr__()

Implement setattr(self, name, value).

<a id="algopy.arc4.Tuple.__sizeof__"></a>

### \_\_sizeof_\_

__sizeof__()

Size of object in memory, in bytes.

<a id="algopy.arc4.Tuple.__str__"></a>

### \_\_str_\_

__str__()

Return str(self).

<a id="algopy.arc4.Tuple.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Tuple.copy"></a>

### copy

copy() → Self

Create a copy of this tuple

<a id="algopy.arc4.Tuple.count"></a>

### count

count()

Return number of occurrences of value.

<a id="algopy.arc4.Tuple.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Tuple.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Tuple.index"></a>

### index

index()

Return first index of value.

Raises ValueError if the value is not present.

<a id="algopy.arc4.Tuple.native"></a>

### *property* native

native *: tuple[Unpack[algopy.arc4._TTuple]]*

Convert to a native Python tuple - note that the elements of the tuple
should be considered to be copies of the original elements

<a id="algopy.arc4.UFixedNxM"></a>

## *class* algopy.arc4.UFixedNxM

UFixedNxM(value: str = '0.0', /)

An ARC4 UFixed representing a decimal with the number of bits and precision specified.

Max size: 64 bits

```python
import typing as t
from algopy import arc4

Decimal: t.TypeAlias = arc4.UFixedNxM[t.Literal[64], t.Literal[10]]
```

## Initialization

Construct an instance of UFixedNxM where value (v) is determined from the original
decimal value (d) by the formula v = round(d \* (10^M))

<a id="algopy.arc4.UFixedNxM.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.UFixedNxM.__eq__"></a>

### \_\_eq_\_

__eq__(other: Self) → bool

Compare for equality, note both operands must be the exact same type

<a id="algopy.arc4.UFixedNxM.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.UFixedNxM.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.UFixedNxM.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.UInt128"></a>

## algopy.arc4.UInt128

UInt128 *: TypeAlias*

None

An ARC4 UInt128

<a id="algopy.arc4.UInt16"></a>

## algopy.arc4.UInt16

UInt16 *: TypeAlias*

None

An ARC4 UInt16

<a id="algopy.arc4.UInt256"></a>

## algopy.arc4.UInt256

UInt256 *: TypeAlias*

None

An ARC4 UInt256

<a id="algopy.arc4.UInt32"></a>

## algopy.arc4.UInt32

UInt32 *: TypeAlias*

None

An ARC4 UInt32

<a id="algopy.arc4.UInt512"></a>

## algopy.arc4.UInt512

UInt512 *: TypeAlias*

None

An ARC4 UInt512

<a id="algopy.arc4.UInt64"></a>

## algopy.arc4.UInt64

UInt64 *: TypeAlias*

None

An ARC4 UInt64

<a id="algopy.arc4.UInt8"></a>

## algopy.arc4.UInt8

UInt8 *: TypeAlias*

None

An ARC4 UInt8

<a id="algopy.arc4.UIntN"></a>

## *class* algopy.arc4.UIntN

UIntN(value: [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, /)

An ARC4 UInt consisting of the number of bits specified (big-endian encoded).

Common bit sizes have also been aliased under     [`algopy.arc4.UInt8`](#algopy.arc4.UInt8), [`algopy.arc4.UInt16`](#algopy.arc4.UInt16) etc.

A uint of any size between 8 and 512 bits (in intervals of 8bits) can be created using a
generic parameter. It can be helpful to define your own alias for this type.

```python
import typing as t
from algopy import arc4

UInt40: t.TypeAlias = arc4.UIntN[t.Literal[40]]
```

Max Size: 64 bits

## Initialization

<a id="algopy.arc4.UIntN.__bool__"></a>

### \_\_bool_\_

__bool__() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.UIntN.__eq__"></a>

### \_\_eq_\_

__eq__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self==value.

<a id="algopy.arc4.UIntN.__ge__"></a>

### \_\_ge_\_

__ge__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>=value.

<a id="algopy.arc4.UIntN.__gt__"></a>

### \_\_gt_\_

__gt__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>value.

<a id="algopy.arc4.UIntN.__le__"></a>

### \_\_le_\_

__le__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<=value.

<a id="algopy.arc4.UIntN.__lt__"></a>

### \_\_lt_\_

__lt__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<value.

<a id="algopy.arc4.UIntN.__ne__"></a>

### \_\_ne_\_

__ne__(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self!=value.

<a id="algopy.arc4.UIntN.bytes"></a>

### *property* bytes

bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.UIntN.from_bytes"></a>

### *classmethod* from_bytes

from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.UIntN.from_log"></a>

### *classmethod* from_log

from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.UIntN.native"></a>

### *property* native

native *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Return the UInt64 representation of the value after ARC4 decoding

<a id="algopy.arc4.abi_call"></a>

## algopy.arc4.abi_call

abi_call *: algopy.arc4._ABICallProtocolType*

Ellipsis

Provides a typesafe way of calling ARC4 methods via an inner transaction

```python
def abi_call(
    self,
    method: Callable[..., _TABIResult_co] | str,
    /,
    *args: _TABIArg,
    app_id: algopy.Application | algopy.UInt64 | int = ...,
    on_completion: algopy.OnCompleteAction = ...,
    approval_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
    clear_state_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
    global_num_uint: UInt64 | int = ...,
    global_num_bytes: UInt64 | int = ...,
    local_num_uint: UInt64 | int = ...,
    local_num_bytes: UInt64 | int = ...,
    extra_program_pages: UInt64 | int = ...,
    fee: algopy.UInt64 | int = 0,
    sender: algopy.Account | str = ...,
    note: algopy.Bytes | algopy.String | bytes | str = ...,
    rekey_to: algopy.Account | str = ...,
) -> tuple[_TABIResult_co, algopy.itxn.ApplicationCallInnerTransaction]: ...
```

PARAMETERS:

**method:** The name, method selector or Algorand Python method to call\<br /\>
\\\\
**app_id:** Application to call, if 0 or not specified will create a new application\<br /\>
\\\\
**on_completion:** OnCompleteAction value for the transaction. If not specified will be inferred from Algorand Python method where possible\<br /\>
\\\\
**approval_program:** When creating or updating an application, the approval program\<br /\>
\\\\
**clear_state_program:** When creating or updating an application, the clear state program\<br /\>
\\\\
**global_num_uint:** When creating an application the number of global uints\<br /\>
\\\\
**global_num_bytes:** When creating an application the number of global bytes\<br /\>
\\\\
**local_num_uint:** When creating an application the number of local uints\<br /\>
\\\\
**local_num_bytes:** When creating an application the number of local bytes\<br /\>
\\\\
**extra_program_pages:** When creating an application the The number of extra program pages\<br /\>
\\\\
**fee:** The fee to pay for the transaction, defaults to 0\<br /\>
\\\\
**sender:** The sender address for the transaction\<br /\>
\\\\
**note:** Note to include with the transaction\<br /\>
\\\\
**rekey_to:** Account to rekey to

RETURNS:\<br /\>
\\\\
If `method` references an Algorand Contract / Client or the function is indexed with a return type,
then the result is a tuple containing the ABI result and the inner transaction of the call.

If no return type is specified, or the method does not have a return value then the result
is the inner transaction of the call.

Examples:

```default
# can reference another algopy contract method
result, txn = abi_call(HelloWorldContract.hello, arc4.String("World"), app=...)
assert result == "Hello, World"

# can reference a method selector
result, txn = abi_call[arc4.String]("hello(string)string", arc4.String("Algo"), app=...)
assert result == "Hello, Algo"

# can reference a method name, the method selector is inferred from arguments and return type
result, txn = abi_call[arc4.String]("hello", "There", app=...)
assert result == "Hello, There"

# calling a method without a return value
txn = abi_call(HelloWorldContract.no_return, arc4.String("World"), app=...)
```

<a id="algopy.arc4.abimethod"></a>

## algopy.arc4.abimethod

abimethod(\*, name: str = ..., create: Literal[allow, require, disallow] = 'disallow', allow_actions: collections.abc.Sequence[[algopy.OnCompleteAction](algopy.mdx#algopy.OnCompleteAction) | Literal[NoOp, OptIn, CloseOut, UpdateApplication, DeleteApplication]] = ('NoOp',), readonly: bool = False, default_args: collections.abc.Mapping[str, str | algopy.arc4._ReadOnlyNoArgsMethod] = ...) → collections.abc.Callable[[collections.abc.Callable[algopy.arc4._P, algopy.arc4._R]], collections.abc.Callable[algopy.arc4._P, algopy.arc4._R]]

Decorator that indicates a method is an ARC4 ABI method. If the method should not be externally
callable, use [`algopy.subroutine()`](algopy.mdx#algopy.subroutine) instead.

Method docstrings will be used when outputting ARC-32 or ARC-56 application specifications,
the following docstrings styles are supported ReST, Google, Numpydoc-style and Epydoc.

```python
from algopy import ARC4Contract, subroutine, arc4


class HelloWorldContract(ARC4Contract):
    @arc4.abimethod(create=False, allow_actions=["NoOp", "OptIn"], name="external_name")
    def hello(self, name: arc4.String) -> arc4.String:
        return self.internal_method() + name

    @subroutine
    def internal_method(self) -> arc4.String:
        return arc4.String("Hello, ")
```

:arg name: Name component of the ABI method selector. Defaults to using the function name.
:arg create: Controls the validation of the Application ID. “require” means it must be zero,
“disallow” requires it must be non-zero, and “allow” disables the validation.
:arg allow_actions: A sequence of allowed On-Completion Actions to validate against.
:arg readonly: If True, then this method can be used via dry-run / simulate.
:arg default_args: Default argument sources for clients to use.

<a id="algopy.arc4.arc4_create"></a>

## algopy.arc4.arc4_create

arc4_create(method: collections.abc.Callable[algopy.arc4._P, algopy.arc4._TABIResult_co], /, \*args: object, compiled: [algopy.CompiledContract](algopy.mdx#algopy.CompiledContract) = ..., on_completion: [algopy.OnCompleteAction](algopy.mdx#algopy.OnCompleteAction) = ..., fee: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, sender: [algopy.Account](algopy.mdx#algopy.Account) | str = ..., note: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes | str = ..., rekey_to: [algopy.Account](algopy.mdx#algopy.Account) | str = ...) → tuple[algopy.arc4._TABIResult_co, [algopy.itxn.ApplicationCallInnerTransaction](algopy.itxn.mdx#algopy.itxn.ApplicationCallInnerTransaction)]

Provides a typesafe and convenient way of creating an ARC4Contract via an inner transaction

:param method: An ARC4 create method (ABI or bare), or an ARC4Contract with a single create method
:param args: ABI args for chosen method
:param compiled: If supplied will be used to specify transaction parameters required for creation,
can be omitted if template variables are not used
:param on_completion: OnCompleteAction value for the transaction
If not specified will be inferred from Algorand Python method where possible
:param fee: The fee to pay for the transaction, defaults to 0
:param sender: The sender address for the transaction
:param note: Note to include with the transaction
:param rekey_to: Account to rekey to

<a id="algopy.arc4.arc4_signature"></a>

## algopy.arc4.arc4_signature

arc4_signature(signature: str, /) → [algopy.Bytes](algopy.mdx#algopy.Bytes)

Returns the ARC4 encoded method selector for the specified signature

<a id="algopy.arc4.arc4_update"></a>

## algopy.arc4.arc4_update

arc4_update(method: collections.abc.Callable[algopy.arc4._P, algopy.arc4._TABIResult_co], /, \*args: object, app_id: [algopy.Application](algopy.mdx#algopy.Application) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, compiled: [algopy.CompiledContract](algopy.mdx#algopy.CompiledContract) = ..., fee: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, sender: [algopy.Account](algopy.mdx#algopy.Account) | str = ..., note: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes | str = ..., rekey_to: [algopy.Account](algopy.mdx#algopy.Account) | str = ...) → tuple[algopy.arc4._TABIResult_co, [algopy.itxn.ApplicationCallInnerTransaction](algopy.itxn.mdx#algopy.itxn.ApplicationCallInnerTransaction)]

Provides a typesafe and convenient way of updating an ARC4Contract via an inner transaction

:param method: An ARC4 update method (ABI or bare), or an ARC4Contract with a single update method
:param args: ABI args for chosen method
:param app_id: Application to update
:param compiled: If supplied will be used to specify transaction parameters required for updating,
can be omitted if template variables are not used
:param fee: The fee to pay for the transaction, defaults to 0
:param sender: The sender address for the transaction
:param note: Note to include with the transaction
:param rekey_to: Account to rekey to

<a id="algopy.arc4.baremethod"></a>

## algopy.arc4.baremethod

baremethod(\*, create: Literal[allow, require, disallow] = 'disallow', allow_actions: collections.abc.Sequence[[algopy.OnCompleteAction](algopy.mdx#algopy.OnCompleteAction) | Literal[NoOp, OptIn, CloseOut, UpdateApplication, DeleteApplication]] = ...) → collections.abc.Callable[[collections.abc.Callable[[algopy.arc4._TARC4Contract], None]], collections.abc.Callable[[algopy.arc4._TARC4Contract], None]]

Decorator that indicates a method is an ARC4 bare method.

There can be only one bare method on a contract for each given On-Completion Action.

:arg create: Controls the validation of the Application ID. “require” means it must be zero,
“disallow” requires it must be non-zero, and “allow” disables the validation.
:arg allow_actions: Which On-Completion Action(s) to handle.

<a id="algopy.arc4.emit"></a>

## algopy.arc4.emit

emit(event: str | [algopy.arc4.Struct](#algopy.arc4.Struct), /, \*args: object) → None

Emit an ARC-28 event for the provided event signature or name, and provided args.

:param event: Either an ARC4 Struct, an event name, or event signature.
\* If event is an ARC4 Struct, the event signature will be determined from the Struct name and fields
\* If event is a signature, then the following args will be typed checked to ensure they match.
\* If event is just a name, the event signature will be inferred from the name and following arguments

:param args: When event is a signature or name, args will be used as the event data.
They will all be encoded as single ARC4 Tuple

Example:

```default
from algopy import ARC4Contract, arc4


class Swapped(arc4.Struct):
    a: arc4.UInt64
    b: arc4.UInt64


class EventEmitter(ARC4Contract):
    @arc4.abimethod
    def emit_swapped(self, a: arc4.UInt64, b: arc4.UInt64) -> None:
        arc4.emit(Swapped(b, a))
        arc4.emit("Swapped(uint64,uint64)", b, a)
        arc4.emit("Swapped", b, a)
```
